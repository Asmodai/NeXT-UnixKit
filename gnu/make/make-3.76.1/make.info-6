This is Info file make.info, produced by Makeinfo version 1.67 from the
input file make.texinfo.

INFO-DIR-SECTION The GNU make utility
START-INFO-DIR-ENTRY
* GNU make: (make.info).           The GNU make utility.
END-INFO-DIR-ENTRY

   This file documents the GNU Make utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

   This is Edition 0.51, last updated 26 Aug 1997, of `The GNU Make
Manual', for `make', Version 3.76 Beta.

   Copyright (C) 1988, '89, '90, '91, '92, '93, '94, '95, '96, '97 	Free
Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: make.info,  Node: Automatic,  Next: Pattern Match,  Prev: Pattern Examples,  Up: Pattern Rules

Automatic Variables
-------------------

   Suppose you are writing a pattern rule to compile a `.c' file into a
`.o' file: how do you write the `cc' command so that it operates on the
right source file name?  You cannot write the name in the command,
because the name is different each time the implicit rule is applied.

   What you do is use a special feature of `make', the "automatic
variables".  These variables have values computed afresh for each rule
that is executed, based on the target and dependencies of the rule.  In
this example, you would use `$@' for the object file name and `$<' for
the source file name.

   Here is a table of automatic variables:

`$@'
     The file name of the target of the rule.  If the target is an
     archive member, then `$@' is the name of the archive file.  In a
     pattern rule that has multiple targets (*note Introduction to
     Pattern Rules: Pattern Intro.), `$@' is the name of whichever
     target caused the rule's commands to be run.

`$%'
     The target member name, when the target is an archive member.
     *Note Archives::.  For example, if the target is `foo.a(bar.o)'
     then `$%' is `bar.o' and `$@' is `foo.a'.  `$%' is empty when the
     target is not an archive member.

`$<'
     The name of the first dependency.  If the target got its commands
     from an implicit rule, this will be the first dependency added by
     the implicit rule (*note Implicit Rules::.).

`$?'
     The names of all the dependencies that are newer than the target,
     with spaces between them.  For dependencies which are archive
     members, only the member named is used (*note Archives::.).

`$^'
     The names of all the dependencies, with spaces between them.  For
     dependencies which are archive members, only the member named is
     used (*note Archives::.).  A target has only one dependency on
     each other file it depends on, no matter how many times each file
     is listed as a dependency.  So if you list a dependency more than
     once for a target, the value of `$^' contains just one copy of the
     name.

`$+'
     This is like `$^', but dependencies listed more than once are
     duplicated in the order they were listed in the makefile.  This is
     primarily useful for use in linking commands where it is
     meaningful to repeat library file names in a particular order.

`$*'
     The stem with which an implicit rule matches (*note How Patterns
     Match: Pattern Match.).  If the target is `dir/a.foo.b' and the
     target pattern is `a.%.b' then the stem is `dir/foo'.  The stem is
     useful for constructing names of related files.

     In a static pattern rule, the stem is part of the file name that
     matched the `%' in the target pattern.

     In an explicit rule, there is no stem; so `$*' cannot be determined
     in that way.  Instead, if the target name ends with a recognized
     suffix (*note Old-Fashioned Suffix Rules: Suffix Rules.), `$*' is
     set to the target name minus the suffix.  For example, if the
     target name is `foo.c', then `$*' is set to `foo', since `.c' is a
     suffix.  GNU `make' does this bizarre thing only for compatibility
     with other implementations of `make'.  You should generally avoid
     using `$*' except in implicit rules or static pattern rules.

     If the target name in an explicit rule does not end with a
     recognized suffix, `$*' is set to the empty string for that rule.

   `$?' is useful even in explicit rules when you wish to operate on
only the dependencies that have changed.  For example, suppose that an
archive named `lib' is supposed to contain copies of several object
files.  This rule copies just the changed object files into the archive:

     lib: foo.o bar.o lose.o win.o
             ar r lib $?

   Of the variables listed above, four have values that are single file
names, and two have values that are lists of file names.  These six have
variants that get just the file's directory name or just the file name
within the directory.  The variant variables' names are formed by
appending `D' or `F', respectively.  These variants are semi-obsolete
in GNU `make' since the functions `dir' and `notdir' can be used to get
a similar effect (*note Functions for File Names: File Name
Functions.).  Note, however, that the `F' variants all omit the
trailing slash which always appears in the output of the `dir'
function.  Here is a table of the variants:

`$(@D)'
     The directory part of the file name of the target, with the
     trailing slash removed.  If the value of `$@' is `dir/foo.o' then
     `$(@D)' is `dir'.  This value is `.' if `$@' does not contain a
     slash.

`$(@F)'
     The file-within-directory part of the file name of the target.  If
     the value of `$@' is `dir/foo.o' then `$(@F)' is `foo.o'.  `$(@F)'
     is equivalent to `$(notdir $@)'.

`$(*D)'
`$(*F)'
     The directory part and the file-within-directory part of the stem;
     `dir' and `foo' in this example.

`$(%D)'
`$(%F)'
     The directory part and the file-within-directory part of the target
     archive member name.  This makes sense only for archive member
     targets of the form `ARCHIVE(MEMBER)' and is useful only when
     MEMBER may contain a directory name.  (*Note Archive Members as
     Targets: Archive Members.)

`$(<D)'
`$(<F)'
     The directory part and the file-within-directory part of the first
     dependency.

`$(^D)'
`$(^F)'
     Lists of the directory parts and the file-within-directory parts
     of all dependencies.

`$(?D)'
`$(?F)'
     Lists of the directory parts and the file-within-directory parts of
     all dependencies that are newer than the target.

   Note that we use a special stylistic convention when we talk about
these automatic variables; we write "the value of `$<'", rather than
"the variable `<'" as we would write for ordinary variables such as
`objects' and `CFLAGS'.  We think this convention looks more natural in
this special case.  Please do not assume it has a deep significance;
`$<' refers to the variable named `<' just as `$(CFLAGS)' refers to the
variable named `CFLAGS'.  You could just as well use `$(<)' in place of
`$<'.


File: make.info,  Node: Pattern Match,  Next: Match-Anything Rules,  Prev: Automatic,  Up: Pattern Rules

How Patterns Match
------------------

   A target pattern is composed of a `%' between a prefix and a suffix,
either or both of which may be empty.  The pattern matches a file name
only if the file name starts with the prefix and ends with the suffix,
without overlap.  The text between the prefix and the suffix is called
the "stem".  Thus, when the pattern `%.o' matches the file name
`test.o', the stem is `test'.  The pattern rule dependencies are turned
into actual file names by substituting the stem for the character `%'.
Thus, if in the same example one of the dependencies is written as
`%.c', it expands to `test.c'.

   When the target pattern does not contain a slash (and it usually does
not), directory names in the file names are removed from the file name
before it is compared with the target prefix and suffix.  After the
comparison of the file name to the target pattern, the directory names,
along with the slash that ends them, are added on to the dependency
file names generated from the pattern rule's dependency patterns and
the file name. The directories are ignored only for the purpose of
finding an implicit rule to use, not in the application of that rule.
Thus, `e%t' matches the file name `src/eat', with `src/a' as the stem.
When dependencies are turned into file names, the directories from the
stem are added at the front, while the rest of the stem is substituted
for the `%'.  The stem `src/a' with a dependency pattern `c%r' gives
the file name `src/car'.


File: make.info,  Node: Match-Anything Rules,  Next: Canceling Rules,  Prev: Pattern Match,  Up: Pattern Rules

Match-Anything Pattern Rules
----------------------------

   When a pattern rule's target is just `%', it matches any file name
whatever.  We call these rules "match-anything" rules.  They are very
useful, but it can take a lot of time for `make' to think about them,
because it must consider every such rule for each file name listed
either as a target or as a dependency.

   Suppose the makefile mentions `foo.c'.  For this target, `make'
would have to consider making it by linking an object file `foo.c.o',
or by C compilation-and-linking in one step from `foo.c.c', or by
Pascal compilation-and-linking from `foo.c.p', and many other
possibilities.

   We know these possibilities are ridiculous since `foo.c' is a C
source file, not an executable.  If `make' did consider these
possibilities, it would ultimately reject them, because files such as
`foo.c.o' and `foo.c.p' would not exist.  But these possibilities are so
numerous that `make' would run very slowly if it had to consider them.

   To gain speed, we have put various constraints on the way `make'
considers match-anything rules.  There are two different constraints
that can be applied, and each time you define a match-anything rule you
must choose one or the other for that rule.

   One choice is to mark the match-anything rule as "terminal" by
defining it with a double colon.  When a rule is terminal, it does not
apply unless its dependencies actually exist.  Dependencies that could
be made with other implicit rules are not good enough.  In other words,
no further chaining is allowed beyond a terminal rule.

   For example, the built-in implicit rules for extracting sources from
RCS and SCCS files are terminal; as a result, if the file `foo.c,v' does
not exist, `make' will not even consider trying to make it as an
intermediate file from `foo.c,v.o' or from `RCS/SCCS/s.foo.c,v'.  RCS
and SCCS files are generally ultimate source files, which should not be
remade from any other files; therefore, `make' can save time by not
looking for ways to remake them.

   If you do not mark the match-anything rule as terminal, then it is
nonterminal.  A nonterminal match-anything rule cannot apply to a file
name that indicates a specific type of data.  A file name indicates a
specific type of data if some non-match-anything implicit rule target
matches it.

   For example, the file name `foo.c' matches the target for the pattern
rule `%.c : %.y' (the rule to run Yacc).  Regardless of whether this
rule is actually applicable (which happens only if there is a file
`foo.y'), the fact that its target matches is enough to prevent
consideration of any nonterminal match-anything rules for the file
`foo.c'.  Thus, `make' will not even consider trying to make `foo.c' as
an executable file from `foo.c.o', `foo.c.c', `foo.c.p', etc.

   The motivation for this constraint is that nonterminal match-anything
rules are used for making files containing specific types of data (such
as executable files) and a file name with a recognized suffix indicates
some other specific type of data (such as a C source file).

   Special built-in dummy pattern rules are provided solely to recognize
certain file names so that nonterminal match-anything rules will not be
considered.  These dummy rules have no dependencies and no commands, and
they are ignored for all other purposes.  For example, the built-in
implicit rule

     %.p :

exists to make sure that Pascal source files such as `foo.p' match a
specific target pattern and thereby prevent time from being wasted
looking for `foo.p.o' or `foo.p.c'.

   Dummy pattern rules such as the one for `%.p' are made for every
suffix listed as valid for use in suffix rules (*note Old-Fashioned
Suffix Rules: Suffix Rules.).


File: make.info,  Node: Canceling Rules,  Prev: Match-Anything Rules,  Up: Pattern Rules

Canceling Implicit Rules
------------------------

   You can override a built-in implicit rule (or one you have defined
yourself) by defining a new pattern rule with the same target and
dependencies, but different commands.  When the new rule is defined, the
built-in one is replaced.  The new rule's position in the sequence of
implicit rules is determined by where you write the new rule.

   You can cancel a built-in implicit rule by defining a pattern rule
with the same target and dependencies, but no commands.  For example,
the following would cancel the rule that runs the assembler:

     %.o : %.s


File: make.info,  Node: Last Resort,  Next: Suffix Rules,  Prev: Pattern Rules,  Up: Implicit Rules

Defining Last-Resort Default Rules
==================================

   You can define a last-resort implicit rule by writing a terminal
match-anything pattern rule with no dependencies (*note Match-Anything
Rules::.).  This is just like any other pattern rule; the only thing
special about it is that it will match any target.  So such a rule's
commands are used for all targets and dependencies that have no commands
of their own and for which no other implicit rule applies.

   For example, when testing a makefile, you might not care if the
source files contain real data, only that they exist.  Then you might
do this:

     %::
             touch $@

to cause all the source files needed (as dependencies) to be created
automatically.

   You can instead define commands to be used for targets for which
there are no rules at all, even ones which don't specify commands.  You
do this by writing a rule for the target `.DEFAULT'.  Such a rule's
commands are used for all dependencies which do not appear as targets in
any explicit rule, and for which no implicit rule applies.  Naturally,
there is no `.DEFAULT' rule unless you write one.

   If you use `.DEFAULT' with no commands or dependencies:

     .DEFAULT:

the commands previously stored for `.DEFAULT' are cleared.  Then `make'
acts as if you had never defined `.DEFAULT' at all.

   If you do not want a target to get the commands from a match-anything
pattern rule or `.DEFAULT', but you also do not want any commands to be
run for the target, you can give it empty commands (*note Defining
Empty Commands: Empty Commands.).

   You can use a last-resort rule to override part of another makefile.
*Note Overriding Part of Another Makefile: Overriding Makefiles.


File: make.info,  Node: Suffix Rules,  Next: Implicit Rule Search,  Prev: Last Resort,  Up: Implicit Rules

Old-Fashioned Suffix Rules
==========================

   "Suffix rules" are the old-fashioned way of defining implicit rules
for `make'.  Suffix rules are obsolete because pattern rules are more
general and clearer.  They are supported in GNU `make' for
compatibility with old makefiles.  They come in two kinds:
"double-suffix" and "single-suffix".

   A double-suffix rule is defined by a pair of suffixes: the target
suffix and the source suffix.  It matches any file whose name ends with
the target suffix.  The corresponding implicit dependency is made by
replacing the target suffix with the source suffix in the file name.  A
two-suffix rule whose target and source suffixes are `.o' and `.c' is
equivalent to the pattern rule `%.o : %.c'.

   A single-suffix rule is defined by a single suffix, which is the
source suffix.  It matches any file name, and the corresponding implicit
dependency name is made by appending the source suffix.  A single-suffix
rule whose source suffix is `.c' is equivalent to the pattern rule `% :
%.c'.

   Suffix rule definitions are recognized by comparing each rule's
target against a defined list of known suffixes.  When `make' sees a
rule whose target is a known suffix, this rule is considered a
single-suffix rule.  When `make' sees a rule whose target is two known
suffixes concatenated, this rule is taken as a double-suffix rule.

   For example, `.c' and `.o' are both on the default list of known
suffixes.  Therefore, if you define a rule whose target is `.c.o',
`make' takes it to be a double-suffix rule with source suffix `.c' and
target suffix `.o'.  Here is the old-fashioned way to define the rule
for compiling a C source file:

     .c.o:
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

   Suffix rules cannot have any dependencies of their own.  If they
have any, they are treated as normal files with funny names, not as
suffix rules.  Thus, the rule:

     .c.o: foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

tells how to make the file `.c.o' from the dependency file `foo.h', and
is not at all like the pattern rule:

     %.o: %.c foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

which tells how to make `.o' files from `.c' files, and makes all `.o'
files using this pattern rule also depend on `foo.h'.

   Suffix rules with no commands are also meaningless.  They do not
remove previous rules as do pattern rules with no commands (*note
Canceling Implicit Rules: Canceling Rules.).  They simply enter the
suffix or pair of suffixes concatenated as a target in the data base.

   The known suffixes are simply the names of the dependencies of the
special target `.SUFFIXES'.  You can add your own suffixes by writing a
rule for `.SUFFIXES' that adds more dependencies, as in:

     .SUFFIXES: .hack .win

which adds `.hack' and `.win' to the end of the list of suffixes.

   If you wish to eliminate the default known suffixes instead of just
adding to them, write a rule for `.SUFFIXES' with no dependencies.  By
special dispensation, this eliminates all existing dependencies of
`.SUFFIXES'.  You can then write another rule to add the suffixes you
want.  For example,

     .SUFFIXES:            # Delete the default suffixes
     .SUFFIXES: .c .o .h   # Define our suffix list

   The `-r' or `--no-builtin-rules' flag causes the default list of
suffixes to be empty.

   The variable `SUFFIXES' is defined to the default list of suffixes
before `make' reads any makefiles.  You can change the list of suffixes
with a rule for the special target `.SUFFIXES', but that does not alter
this variable.


File: make.info,  Node: Implicit Rule Search,  Prev: Suffix Rules,  Up: Implicit Rules

Implicit Rule Search Algorithm
==============================

   Here is the procedure `make' uses for searching for an implicit rule
for a target T.  This procedure is followed for each double-colon rule
with no commands, for each target of ordinary rules none of which have
commands, and for each dependency that is not the target of any rule.
It is also followed recursively for dependencies that come from implicit
rules, in the search for a chain of rules.

   Suffix rules are not mentioned in this algorithm because suffix
rules are converted to equivalent pattern rules once the makefiles have
been read in.

   For an archive member target of the form `ARCHIVE(MEMBER)', the
following algorithm is run twice, first using the entire target name T,
and second using `(MEMBER)' as the target T if the first run found no
rule.

  1. Split T into a directory part, called D, and the rest, called N.
     For example, if T is `src/foo.o', then D is `src/' and N is
     `foo.o'.

  2. Make a list of all the pattern rules one of whose targets matches
     T or N.  If the target pattern contains a slash, it is matched
     against T; otherwise, against N.

  3. If any rule in that list is *not* a match-anything rule, then
     remove all nonterminal match-anything rules from the list.

  4. Remove from the list all rules with no commands.

  5. For each pattern rule in the list:

       a. Find the stem S, which is the nonempty part of T or N matched
          by the `%' in the target pattern.

       b. Compute the dependency names by substituting S for `%'; if
          the target pattern does not contain a slash, append D to the
          front of each dependency name.

       c. Test whether all the dependencies exist or ought to exist.
          (If a file name is mentioned in the makefile as a target or
          as an explicit dependency, then we say it ought to exist.)

          If all dependencies exist or ought to exist, or there are no
          dependencies, then this rule applies.

  6. If no pattern rule has been found so far, try harder.  For each
     pattern rule in the list:

       a. If the rule is terminal, ignore it and go on to the next rule.

       b. Compute the dependency names as before.

       c. Test whether all the dependencies exist or ought to exist.

       d. For each dependency that does not exist, follow this algorithm
          recursively to see if the dependency can be made by an
          implicit rule.

       e. If all dependencies exist, ought to exist, or can be made by
          implicit rules, then this rule applies.

  7. If no implicit rule applies, the rule for `.DEFAULT', if any,
     applies.  In that case, give T the same commands that `.DEFAULT'
     has.  Otherwise, there are no commands for T.

   Once a rule that applies has been found, for each target pattern of
the rule other than the one that matched T or N, the `%' in the pattern
is replaced with S and the resultant file name is stored until the
commands to remake the target file T are executed.  After these
commands are executed, each of these stored file names are entered into
the data base and marked as having been updated and having the same
update status as the file T.

   When the commands of a pattern rule are executed for T, the automatic
variables are set corresponding to the target and dependencies.  *Note
Automatic Variables: Automatic.


File: make.info,  Node: Archives,  Next: Features,  Prev: Implicit Rules,  Up: Top

Using `make' to Update Archive Files
************************************

   "Archive files" are files containing named subfiles called
"members"; they are maintained with the program `ar' and their main use
is as subroutine libraries for linking.

* Menu:

* Archive Members::             Archive members as targets.
* Archive Update::              The implicit rule for archive member targets.
* Archive Pitfalls::            Dangers to watch out for when using archives.
* Archive Suffix Rules::        You can write a special kind of suffix rule
                                  for updating archives.


File: make.info,  Node: Archive Members,  Next: Archive Update,  Up: Archives

Archive Members as Targets
==========================

   An individual member of an archive file can be used as a target or
dependency in `make'.  You specify the member named MEMBER in archive
file ARCHIVE as follows:

     ARCHIVE(MEMBER)

This construct is available only in targets and dependencies, not in
commands!  Most programs that you might use in commands do not support
this syntax and cannot act directly on archive members.  Only `ar' and
other programs specifically designed to operate on archives can do so.
Therefore, valid commands to update an archive member target probably
must use `ar'.  For example, this rule says to create a member `hack.o'
in archive `foolib' by copying the file `hack.o':

     foolib(hack.o) : hack.o
             ar cr foolib hack.o

   In fact, nearly all archive member targets are updated in just this
way and there is an implicit rule to do it for you.  *Note:* The `c'
flag to `ar' is required if the archive file does not already exist.

   To specify several members in the same archive, you can write all the
member names together between the parentheses.  For example:

     foolib(hack.o kludge.o)

is equivalent to:

     foolib(hack.o) foolib(kludge.o)

   You can also use shell-style wildcards in an archive member
reference.  *Note Using Wildcard Characters in File Names: Wildcards.
For example, `foolib(*.o)' expands to all existing members of the
`foolib' archive whose names end in `.o'; perhaps `foolib(hack.o)
foolib(kludge.o)'.


File: make.info,  Node: Archive Update,  Next: Archive Pitfalls,  Prev: Archive Members,  Up: Archives

Implicit Rule for Archive Member Targets
========================================

   Recall that a target that looks like `A(M)' stands for the member
named M in the archive file A.

   When `make' looks for an implicit rule for such a target, as a
special feature it considers implicit rules that match `(M)', as well as
those that match the actual target `A(M)'.

   This causes one special rule whose target is `(%)' to match.  This
rule updates the target `A(M)' by copying the file M into the archive.
For example, it will update the archive member target `foo.a(bar.o)' by
copying the *file* `bar.o' into the archive `foo.a' as a *member* named
`bar.o'.

   When this rule is chained with others, the result is very powerful.
Thus, `make "foo.a(bar.o)"' (the quotes are needed to protect the `('
and `)' from being interpreted specially by the shell) in the presence
of a file `bar.c' is enough to cause the following commands to be run,
even without a makefile:

     cc -c bar.c -o bar.o
     ar r foo.a bar.o
     rm -f bar.o

Here `make' has envisioned the file `bar.o' as an intermediate file.
*Note Chains of Implicit Rules: Chained Rules.

   Implicit rules such as this one are written using the automatic
variable `$%'.  *Note Automatic Variables: Automatic.

   An archive member name in an archive cannot contain a directory
name, but it may be useful in a makefile to pretend that it does.  If
you write an archive member target `foo.a(dir/file.o)', `make' will
perform automatic updating with this command:

     ar r foo.a dir/file.o

which has the effect of copying the file `dir/file.o' into a member
named `file.o'.  In connection with such usage, the automatic variables
`%D' and `%F' may be useful.

* Menu:

* Archive Symbols::             How to update archive symbol directories.


File: make.info,  Node: Archive Symbols,  Up: Archive Update

Updating Archive Symbol Directories
-----------------------------------

   An archive file that is used as a library usually contains a special
member named `__.SYMDEF' that contains a directory of the external
symbol names defined by all the other members.  After you update any
other members, you need to update `__.SYMDEF' so that it will summarize
the other members properly.  This is done by running the `ranlib'
program:

     ranlib ARCHIVEFILE

   Normally you would put this command in the rule for the archive file,
and make all the members of the archive file dependencies of that rule.
For example,

     libfoo.a: libfoo.a(x.o) libfoo.a(y.o) ...
             ranlib libfoo.a

The effect of this is to update archive members `x.o', `y.o', etc., and
then update the symbol directory member `__.SYMDEF' by running
`ranlib'.  The rules for updating the members are not shown here; most
likely you can omit them and use the implicit rule which copies files
into the archive, as described in the preceding section.

   This is not necessary when using the GNU `ar' program, which updates
the `__.SYMDEF' member automatically.


File: make.info,  Node: Archive Pitfalls,  Next: Archive Suffix Rules,  Prev: Archive Update,  Up: Archives

Dangers When Using Archives
===========================

   It is important to be careful when using parallel execution (the
`-j' switch; *note Parallel Execution: Parallel.) and archives.  If
multiple `ar' commands run at the same time on the same archive file,
they will not know about each other and can corrupt the file.

   Possibly a future version of `make' will provide a mechanism to
circumvent this problem by serializing all commands that operate on the
same archive file.  But for the time being, you must either write your
makefiles to avoid this problem in some other way, or not use `-j'.


File: make.info,  Node: Archive Suffix Rules,  Prev: Archive Pitfalls,  Up: Archives

Suffix Rules for Archive Files
==============================

   You can write a special kind of suffix rule for dealing with archive
files.  *Note Suffix Rules::, for a full explanation of suffix rules.
Archive suffix rules are obsolete in GNU `make', because pattern rules
for archives are a more general mechanism (*note Archive Update::.).
But they are retained for compatibility with other `make's.

   To write a suffix rule for archives, you simply write a suffix rule
using the target suffix `.a' (the usual suffix for archive files).  For
example, here is the old-fashioned suffix rule to update a library
archive from C source files:

     .c.a:
             $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
             $(AR) r $@ $*.o
             $(RM) $*.o

This works just as if you had written the pattern rule:

     (%.o): %.c
             $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
             $(AR) r $@ $*.o
             $(RM) $*.o

   In fact, this is just what `make' does when it sees a suffix rule
with `.a' as the target suffix.  Any double-suffix rule `.X.a' is
converted to a pattern rule with the target pattern `(%.o)' and a
dependency pattern of `%.X'.

   Since you might want to use `.a' as the suffix for some other kind
of file, `make' also converts archive suffix rules to pattern rules in
the normal way (*note Suffix Rules::.).  Thus a double-suffix rule
`.X.a' produces two pattern rules: `(%.o): %.X' and `%.a: %.X'.


File: make.info,  Node: Features,  Next: Missing,  Prev: Archives,  Up: Top

Features of GNU `make'
**********************

   Here is a summary of the features of GNU `make', for comparison with
and credit to other versions of `make'.  We consider the features of
`make' in 4.2 BSD systems as a baseline.  If you are concerned with
writing portable makefiles, you should use only the features of `make'
*not* listed here or in *Note Missing::.

   Many features come from the version of `make' in System V.

   * The `VPATH' variable and its special meaning.  *Note Searching
     Directories for Dependencies: Directory Search.  This feature
     exists in System V `make', but is undocumented.  It is documented
     in 4.3 BSD `make' (which says it mimics System V's `VPATH'
     feature).

   * Included makefiles.  *Note Including Other Makefiles: Include.
     Allowing multiple files to be included with a single directive is
     a GNU extension.

   * Variables are read from and communicated via the environment.
     *Note Variables from the Environment: Environment.

   * Options passed through the variable `MAKEFLAGS' to recursive
     invocations of `make'.  *Note Communicating Options to a
     Sub-`make': Options/Recursion.

   * The automatic variable `$%' is set to the member name in an
     archive reference.  *Note Automatic Variables: Automatic.

   * The automatic variables `$@', `$*', `$<', `$%', and `$?' have
     corresponding forms like `$(@F)' and `$(@D)'.  We have generalized
     this to `$^' as an obvious extension.  *Note Automatic Variables:
     Automatic.

   * Substitution variable references.  *Note Basics of Variable
     References: Reference.

   * The command-line options `-b' and `-m', accepted and ignored.  In
     System V `make', these options actually do something.

   * Execution of recursive commands to run `make' via the variable
     `MAKE' even if `-n', `-q' or `-t' is specified.  *Note Recursive
     Use of `make': Recursion.

   * Support for suffix `.a' in suffix rules.  *Note Archive Suffix
     Rules::.  This feature is obsolete in GNU `make', because the
     general feature of rule chaining (*note Chains of Implicit Rules:
     Chained Rules.) allows one pattern rule for installing members in
     an archive (*note Archive Update::.) to be sufficient.

   * The arrangement of lines and backslash-newline combinations in
     commands is retained when the commands are printed, so they appear
     as they do in the makefile, except for the stripping of initial
     whitespace.

   The following features were inspired by various other versions of
`make'.  In some cases it is unclear exactly which versions inspired
which others.

   * Pattern rules using `%'.  This has been implemented in several
     versions of `make'.  We're not sure who invented it first, but
     it's been spread around a bit.  *Note Defining and Redefining
     Pattern Rules: Pattern Rules.

   * Rule chaining and implicit intermediate files.  This was
     implemented by Stu Feldman in his version of `make' for AT&T
     Eighth Edition Research Unix, and later by Andrew Hume of AT&T
     Bell Labs in his `mk' program (where he terms it "transitive
     closure").  We do not really know if we got this from either of
     them or thought it up ourselves at the same time.  *Note Chains of
     Implicit Rules: Chained Rules.

   * The automatic variable `$^' containing a list of all dependencies
     of the current target.  We did not invent this, but we have no
     idea who did.  *Note Automatic Variables: Automatic.  The
     automatic variable `$+' is a simple extension of `$^'.

   * The "what if" flag (`-W' in GNU `make') was (as far as we know)
     invented by Andrew Hume in `mk'.  *Note Instead of Executing the
     Commands: Instead of Execution.

   * The concept of doing several things at once (parallelism) exists in
     many incarnations of `make' and similar programs, though not in the
     System V or BSD implementations.  *Note Command Execution:
     Execution.

   * Modified variable references using pattern substitution come from
     SunOS 4.  *Note Basics of Variable References: Reference.  This
     functionality was provided in GNU `make' by the `patsubst'
     function before the alternate syntax was implemented for
     compatibility with SunOS 4.  It is not altogether clear who
     inspired whom, since GNU `make' had `patsubst' before SunOS 4 was
     released.

   * The special significance of `+' characters preceding command lines
     (*note Instead of Executing the Commands: Instead of Execution.) is
     mandated by `IEEE Standard 1003.2-1992' (POSIX.2).

   * The `+=' syntax to append to the value of a variable comes from
     SunOS 4 `make'.  *Note Appending More Text to Variables: Appending.

   * The syntax `ARCHIVE(MEM1 MEM2...)' to list multiple members in a
     single archive file comes from SunOS 4 `make'.  *Note Archive
     Members::.

   * The `-include' directive to include makefiles with no error for a
     nonexistent file comes from SunOS 4 `make'.  (But note that SunOS 4
     `make' does not allow multiple makefiles to be specified in one
     `-include' directive.)  The same feature appears with the name
     `sinclude' in SGI `make' and perhaps others.

   The remaining features are inventions new in GNU `make':

   * Use the `-v' or `--version' option to print version and copyright
     information.

   * Use the `-h' or `--help' option to summarize the options to `make'.

   * Simply-expanded variables.  *Note The Two Flavors of Variables:
     Flavors.

   * Pass command-line variable assignments automatically through the
     variable `MAKE' to recursive `make' invocations.  *Note Recursive
     Use of `make': Recursion.

   * Use the `-C' or `--directory' command option to change directory.
     *Note Summary of Options: Options Summary.

   * Make verbatim variable definitions with `define'.  *Note Defining
     Variables Verbatim: Defining.

   * Declare phony targets with the special target `.PHONY'.

     Andrew Hume of AT&T Bell Labs implemented a similar feature with a
     different syntax in his `mk' program.  This seems to be a case of
     parallel discovery.  *Note Phony Targets: Phony Targets.

   * Manipulate text by calling functions.  *Note Functions for
     Transforming Text: Functions.

   * Use the `-o' or `--old-file' option to pretend a file's
     modification-time is old.  *Note Avoiding Recompilation of Some
     Files: Avoiding Compilation.

   * Conditional execution.

     This feature has been implemented numerous times in various
     versions of `make'; it seems a natural extension derived from the
     features of the C preprocessor and similar macro languages and is
     not a revolutionary concept.  *Note Conditional Parts of
     Makefiles: Conditionals.

   * Specify a search path for included makefiles.  *Note Including
     Other Makefiles: Include.

   * Specify extra makefiles to read with an environment variable.
     *Note The Variable `MAKEFILES': MAKEFILES Variable.

   * Strip leading sequences of `./' from file names, so that `./FILE'
     and `FILE' are considered to be the same file.

   * Use a special search method for library dependencies written in the
     form `-lNAME'.  *Note Directory Search for Link Libraries:
     Libraries/Search.

   * Allow suffixes for suffix rules (*note Old-Fashioned Suffix Rules:
     Suffix Rules.) to contain any characters.  In other versions of
     `make', they must begin with `.' and not contain any `/'
     characters.

   * Keep track of the current level of `make' recursion using the
     variable `MAKELEVEL'.  *Note Recursive Use of `make': Recursion.

   * Provide any goals given on the command line in the variable
     `MAKECMDGOALS'.  *Note Arguments to Specify the Goals: Goals.

   * Specify static pattern rules.  *Note Static Pattern Rules: Static
     Pattern.

   * Provide selective `vpath' search.  *Note Searching Directories for
     Dependencies: Directory Search.

   * Provide computed variable references.  *Note Basics of Variable
     References: Reference.

   * Update makefiles.  *Note How Makefiles Are Remade: Remaking
     Makefiles.  System V `make' has a very, very limited form of this
     functionality in that it will check out SCCS files for makefiles.

   * Various new built-in implicit rules.  *Note Catalogue of Implicit
     Rules: Catalogue of Rules.

   * The built-in variable `MAKE_VERSION' gives the version number of
     `make'.


File: make.info,  Node: Missing,  Next: Makefile Conventions,  Prev: Features,  Up: Top

Incompatibilities and Missing Features
**************************************

   The `make' programs in various other systems support a few features
that are not implemented in GNU `make'.  The POSIX.2 standard (`IEEE
Standard 1003.2-1992') which specifies `make' does not require any of
these features.

   * A target of the form `FILE((ENTRY))' stands for a member of
     archive file FILE.  The member is chosen, not by name, but by
     being an object file which defines the linker symbol ENTRY.

     This feature was not put into GNU `make' because of the
     nonmodularity of putting knowledge into `make' of the internal
     format of archive file symbol tables.  *Note Updating Archive
     Symbol Directories: Archive Symbols.

   * Suffixes (used in suffix rules) that end with the character `~'
     have a special meaning to System V `make'; they refer to the SCCS
     file that corresponds to the file one would get without the `~'.
     For example, the suffix rule `.c~.o' would make the file `N.o' from
     the SCCS file `s.N.c'.  For complete coverage, a whole series of
     such suffix rules is required.  *Note Old-Fashioned Suffix Rules:
     Suffix Rules.

     In GNU `make', this entire series of cases is handled by two
     pattern rules for extraction from SCCS, in combination with the
     general feature of rule chaining.  *Note Chains of Implicit Rules:
     Chained Rules.

   * In System V `make', the string `$$@' has the strange meaning that,
     in the dependencies of a rule with multiple targets, it stands for
     the particular target that is being processed.

     This is not defined in GNU `make' because `$$' should always stand
     for an ordinary `$'.

     It is possible to get this functionality through the use of static
     pattern rules (*note Static Pattern Rules: Static Pattern.).  The
     System V `make' rule:

          $(targets): $$@.o lib.a

     can be replaced with the GNU `make' static pattern rule:

          $(targets): %: %.o lib.a

   * In System V and 4.3 BSD `make', files found by `VPATH' search
     (*note Searching Directories for Dependencies: Directory Search.)
     have their names changed inside command strings.  We feel it is
     much cleaner to always use automatic variables and thus make this
     feature obsolete.

   * In some Unix `make's, the automatic variable `$*' appearing in the
     dependencies of a rule has the amazingly strange "feature" of
     expanding to the full name of the *target of that rule*.  We cannot
     imagine what went on in the minds of Unix `make' developers to do
     this; it is utterly inconsistent with the normal definition of
     `$*'.

   * In some Unix `make's, implicit rule search (*note Using Implicit
     Rules: Implicit Rules.) is apparently done for *all* targets, not
     just those without commands.  This means you can do:

          foo.o:
                  cc -c foo.c

     and Unix `make' will intuit that `foo.o' depends on `foo.c'.

     We feel that such usage is broken.  The dependency properties of
     `make' are well-defined (for GNU `make', at least), and doing such
     a thing simply does not fit the model.

   * GNU `make' does not include any built-in implicit rules for
     compiling or preprocessing EFL programs.  If we hear of anyone who
     is using EFL, we will gladly add them.

   * It appears that in SVR4 `make', a suffix rule can be specified with
     no commands, and it is treated as if it had empty commands (*note
     Empty Commands::.).  For example:

          .c.a:

     will override the built-in `.c.a' suffix rule.

     We feel that it is cleaner for a rule without commands to always
     simply add to the dependency list for the target.  The above
     example can be easily rewritten to get the desired behavior in GNU
     `make':

          .c.a: ;

   * Some versions of `make' invoke the shell with the `-e' flag,
     except under `-k' (*note Testing the Compilation of a Program:
     Testing.).  The `-e' flag tells the shell to exit as soon as any
     program it runs returns a nonzero status.  We feel it is cleaner to
     write each shell command line to stand on its own and not require
     this special treatment.


File: make.info,  Node: Makefile Conventions,  Next: Quick Reference,  Prev: Missing,  Up: Top

Makefile Conventions
********************

   This node describes conventions for writing the Makefiles for GNU
programs.

* Menu:

* Makefile Basics::		General Conventions for Makefiles
* Utilities in Makefiles::	Utilities in Makefiles
* Command Variables::		Variables for Specifying Commands
* Directory Variables::		Variables for Installation Directories
* Standard Targets::		Standard Targets for Users
* Install Command Categories::  Three categories of commands in the `install'
                                  rule: normal, pre-install and post-install.


File: make.info,  Node: Makefile Basics,  Next: Utilities in Makefiles,  Up: Makefile Conventions

General Conventions for Makefiles
=================================

   Every Makefile should contain this line:

     SHELL = /bin/sh

to avoid trouble on systems where the `SHELL' variable might be
inherited from the environment.  (This is never a problem with GNU
`make'.)

   Different `make' programs have incompatible suffix lists and
implicit rules, and this sometimes creates confusion or misbehavior.  So
it is a good idea to set the suffix list explicitly using only the
suffixes you need in the particular Makefile, like this:

     .SUFFIXES:
     .SUFFIXES: .c .o

The first line clears out the suffix list, the second introduces all
suffixes which may be subject to implicit rules in this Makefile.

   Don't assume that `.' is in the path for command execution.  When
you need to run programs that are a part of your package during the
make, please make sure that it uses `./' if the program is built as
part of the make or `$(srcdir)/' if the file is an unchanging part of
the source code.  Without one of these prefixes, the current search
path is used.

   The distinction between `./' (the "build directory") and
`$(srcdir)/' (the "source directory") is important because users can
build in a separate directory using the `--srcdir' option to
`configure'.  A rule of the form:

     foo.1 : foo.man sedscript
             sed -e sedscript foo.man > foo.1

will fail when the build directory is not the source directory, because
`foo.man' and `sedscript' are in the the source directory.

   When using GNU `make', relying on `VPATH' to find the source file
will work in the case where there is a single dependency file, since
the `make' automatic variable `$<' will represent the source file
wherever it is.  (Many versions of `make' set `$<' only in implicit
rules.)  A Makefile target like

     foo.o : bar.c
             $(CC) -I. -I$(srcdir) $(CFLAGS) -c bar.c -o foo.o

should instead be written as

     foo.o : bar.c
             $(CC) -I. -I$(srcdir) $(CFLAGS) -c $< -o $@

in order to allow `VPATH' to work correctly.  When the target has
multiple dependencies, using an explicit `$(srcdir)' is the easiest way
to make the rule work well.  For example, the target above for `foo.1'
is best written as:

     foo.1 : foo.man sedscript
             sed -e $(srcdir)/sedscript $(srcdir)/foo.man > $@

   GNU distributions usually contain some files which are not source
files--for example, Info files, and the output from Autoconf, Automake,
Bison or Flex.  Since these files normally appear in the source
directory, they should always appear in the source directory, not in the
build directory.  So Makefile rules to update them should put the
updated files in the source directory.

   However, if a file does not appear in the distribution, then the
Makefile should not put it in the source directory, because building a
program in ordinary circumstances should not modify the source directory
in any way.

   Try to make the build and installation targets, at least (and all
their subtargets) work correctly with a parallel `make'.


File: make.info,  Node: Utilities in Makefiles,  Next: Command Variables,  Prev: Makefile Basics,  Up: Makefile Conventions

Utilities in Makefiles
======================

   Write the Makefile commands (and any shell scripts, such as
`configure') to run in `sh', not in `csh'.  Don't use any special
features of `ksh' or `bash'.

   The `configure' script and the Makefile rules for building and
installation should not use any utilities directly except these:

     cat cmp cp diff echo egrep expr false grep install-info
     ln ls mkdir mv pwd rm rmdir sed sleep sort tar test touch true

   The compression program `gzip' can be used in the `dist' rule.

   Stick to the generally supported options for these programs.  For
example, don't use `mkdir -p', convenient as it may be, because most
systems don't support it.

   It is a good idea to avoid creating symbolic links in makefiles,
since a few systems don't support them.

   The Makefile rules for building and installation can also use
compilers and related programs, but should do so via `make' variables
so that the user can substitute alternatives.  Here are some of the
programs we mean:

     ar bison cc flex install ld ldconfig lex
     make makeinfo ranlib texi2dvi yacc

   Use the following `make' variables to run those programs:

     $(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX)
     $(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC)

   When you use `ranlib' or `ldconfig', you should make sure nothing
bad happens if the system does not have the program in question.
Arrange to ignore an error from that command, and print a message before
the command to tell the user that failure of this command does not mean
a problem.  (The Autoconf `AC_PROG_RANLIB' macro can help with this.)

   If you use symbolic links, you should implement a fallback for
systems that don't have symbolic links.

   Additional utilities that can be used via Make variables are:

     chgrp chmod chown mknod

   It is ok to use other utilities in Makefile portions (or scripts)
intended only for particular systems where you know those utilities
exist.

