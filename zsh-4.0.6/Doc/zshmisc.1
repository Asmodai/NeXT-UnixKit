.TH "ZSHMISC" "1" "August 14, 2002" "zsh 4\&.0\&.6"
.SH "NAME"
zshmisc \- everything and then some
.\" Yodl file: Zsh/grammar.yo
.SH "SIMPLE COMMANDS & PIPELINES"
A \fIsimple command\fP is a sequence of optional parameter
assignments followed by blank\-separated words,
with optional redirections interspersed\&.
The first word is the command to be executed, and the remaining
words, if any, are arguments to the command\&.
If a command name is given, the parameter assignments modify
the environment of the command when it is executed\&.
The value of a simple command is its exit status,
or 128 plus the signal number if terminated by a signal\&.
For example,
.PP
.RS
.nf
\fBecho foo\fP
.fi
.RE
.PP
is a simple command with arguments\&.
.PP
A \fIpipeline\fP is either a simple command, or a sequence of two or more
simple commands where each command is separated from the next by `\fB|\fP'
or `\fB|&\fP'\&.  Where commands are separated by `\fB|\fP', the standard
output of the first command is connected to the
standard input of the next\&.  `\fB|&\fP' is shorthand for `\fB2>&1 |\fP', which
connects both the standard output and the standard error of the
command to the standard input of the next\&.  The value of a pipeline
is the value of the last command, unless the pipeline is preceded by
`\fB!\fP' in which case the value is the logical inverse of the value of the
last command\&.
For example,
.PP
.RS
.nf
\fBecho foo | sed 's/foo/bar/'\fP
.fi
.RE
.PP
is a pipeline, where the output (`\fBfoo\fP' plus a newline) of the first
command will be passed to the input of the second\&.
.PP
If a pipeline is preceded by `\fBcoproc\fP', it is executed as a coprocess;
a two\-way pipe is established between it and the parent shell\&.  The
shell can read from or write to the coprocess by means of the `\fB>&p\fP'
and `\fB<&p\fP' redirection operators or with `\fBprint \-p\fP' and `\fBread \-p\fP'\&.
A pipeline cannot be preceded by both `\fBcoproc\fP' and `\fB!\fP'\&.
If job control is active, the coprocess can be treated in other than input
and output as an ordinary background job\&.
.PP
A \fIsublist\fP is either a single pipeline, or a sequence of two or more
pipelines separated by `\fB&&\fP' or `\fB||\fP'\&.  If two pipelines are separated
by `\fB&&\fP', the second pipeline is executed only if the first succeeds
(returns a zero value)\&.  If two pipelines are separated by `\fB||\fP', the
second is executed only if the first fails (returns a nonzero value)\&.
Both operators have equal precedence and are left associative\&.
The value of the sublist is the value of the last pipeline executed\&.
For example,
.PP
.RS
.nf
\fBdmesg | grep panic && print yes\fP
.fi
.RE
.PP
is a sublist consisting of two pipelines, the second just a simple command
which will be executed if and only if the \fBgrep\fP command returns a zero
value\&.  If it does not, the value of the sublist is that return value, else
it is the value returned by the \fBprint\fP (almost certainly zero)\&.
.PP
A \fIlist\fP is a sequence of zero or more sublists, in which each sublist
is terminated by `\fB;\fP', `\fB&\fP', `\fB&|\fP', `\fB&!\fP', or a newline\&.
This terminator
may optionally be omitted from the last sublist in the list when the
list appears as a complex command inside `\fB(\fP\&.\&.\&.\fB)\fP'
or `\fB{\fP\&.\&.\&.\fB}\fP'\&.  When a
sublist is terminated by `\fB;\fP' or newline, the shell waits for it to
finish before executing the next sublist\&.  If a sublist is terminated
by a `\fB&\fP', `\fB&|\fP', or `\fB&!\fP',
the shell executes the last pipeline in it in the background, and
does not wait for it to finish (note the difference from other shells
which execute the whole sublist in the background)\&.
A backgrounded pipeline returns a status of zero\&.
.PP
More generally, a list can be seen as a set of any shell commands
whatsoever, including the complex commands below; this is implied wherever
the word `list' appears in later descriptions\&.  For example, the commands
in a shell function form a special sort of list\&.
.SH "PRECOMMAND MODIFIERS"
A simple command may be preceded by a \fIprecommand modifier\fP,
which will alter how the command is interpreted\&.  These modifiers are
shell builtin commands with the exception of \fBnocorrect\fP which is
a reserved word\&.
.PP
.PD 0
.TP
.PD
\fB\-\fP
The command is executed with a `\fB\-\fP' prepended to its
\fBargv[0]\fP string\&.
.TP
\fBnoglob\fP
Filename generation (globbing) is not performed on any of
the words\&.
.TP
\fBnocorrect\fP
Spelling correction is not done on any of the words\&.  This must appear
before any other precommand modifier, as it is interpreted immediately,
before any parsing is done\&.  It has no effect in non\-interactive shells\&.
.TP
\fBexec\fP
The command is executed in the parent shell without forking\&.
.TP
\fBcommand\fP
The command word is taken to be the name of an external command,
rather than a shell function or builtin\&.
.TP
\fBbuiltin\fP
The command word is taken to be the name of a builtin command,
rather than a shell function or external command\&.
.SH "COMPLEX COMMANDS"
A \fIcomplex command\fP in zsh is one of the following:
.PP
.PD 0
.TP
.PD
\fBif\fP \fIlist\fP \fBthen\fP \fIlist\fP [ \fBelif\fP \fIlist\fP \fBthen\fP \fIlist\fP ] \&.\&.\&. [ \fBelse\fP \fIlist\fP ] \fBfi\fP
The \fBif\fP \fIlist\fP is executed, and if it returns a zero exit status,
the \fBthen\fP \fIlist\fP is executed\&.
Otherwise, the \fBelif\fP \fIlist\fP is executed and if its value is zero,
the \fBthen\fP \fIlist\fP is executed\&.
If each \fBelif\fP \fIlist\fP returns nonzero, the \fBelse\fP \fIlist\fP is executed\&.
.TP
\fBfor\fP \fIname\fP [ \fBin\fP \fIword\fP \&.\&.\&. \fIterm\fP ] \fBdo\fP \fIlist\fP \fBdone\fP
where \fIterm\fP is at least one newline or \fB;\fP\&.
Expand the list of \fIword\fPs, and set the parameter
\fIname\fP to each of them in turn, executing
\fIlist\fP each time\&.  If the \fBin\fP \fIword\fP is omitted,
use the positional parameters instead of the \fIword\fPs\&.
.TP
\fBfor ((\fP [\fIexpr1\fP] \fB;\fP [\fIexpr2\fP] \fB;\fP [\fIexpr3\fP] \fB)) do\fP \fIlist\fP \fBdone\fP
The arithmetic expression \fIexpr1\fP is evaluated first (see
the section `Arithmetic Evaluation')\&.  The arithmetic expression
\fIexpr2\fP is repeatedly evaluated until it evaluates to zero and
when non\-zero, \fIlist\fP is executed and the arithmetic expression
\fIexpr3\fP evaluated\&.  If any expression is omitted, then it behaves
as if it evaluated to 1\&.
.TP
\fBwhile\fP \fIlist\fP \fBdo\fP \fIlist\fP \fBdone\fP
Execute the \fBdo\fP \fIlist\fP as long as the \fBwhile\fP \fIlist\fP
returns a zero exit status\&.
.TP
\fBuntil\fP \fIlist\fP \fBdo\fP \fIlist\fP \fBdone\fP
Execute the \fBdo\fP \fIlist\fP as long as \fBuntil\fP \fIlist\fP
returns a nonzero exit status\&.
.TP
\fBrepeat\fP \fIword\fP \fBdo\fP \fIlist\fP \fBdone\fP
\fIword\fP is expanded and treated as an arithmetic expression,
which must evaluate to a number \fIn\fP\&.
\fIlist\fP is then executed \fIn\fP times\&.
.TP
\fBcase\fP \fIword\fP \fBin\fP [ [\fB(\fP] \fIpattern\fP [ \fB|\fP \fIpattern\fP ] \&.\&.\&. \fB)\fP \fIlist\fP (\fB;;\fP|\fB;&\fP) ] \&.\&.\&. \fBesac\fP
Execute the \fIlist\fP associated with the first \fIpattern\fP
that matches \fIword\fP, if any\&.  The form of the patterns
is the same as that used for filename generation\&.  See
the section `Filename Generation'\&.
If the \fIlist\fP that is executed is terminated with \fB;&\fP rather than
\fB;;\fP, the following list is also executed\&.  This continues until either
a list is terminated with \fB;;\fP or the \fBesac\fP is reached\&.
.TP
\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP \&.\&.\&. \fIterm\fP ] \fBdo\fP \fIlist\fP \fBdone\fP
where \fIterm\fP is one or more newline or \fB;\fP to terminate the \fIword\fPs\&.
Print the set of \fIword\fPs, each preceded by a number\&.
If the \fBin\fP \fIword\fP is omitted, use the positional parameters\&.
The \fBPROMPT3\fP prompt is printed and a line is read from the line editor
if the shell is interactive and that is active, or else standard input\&.
If this line consists of the
number of one of the listed \fIword\fPs, then the parameter \fIname\fP
is set to the \fIword\fP corresponding to this number\&.
If this line is empty, the selection list is printed again\&.
Otherwise, the value of the parameter \fIname\fP is set to null\&.
The contents of the line read from standard input is saved
in the parameter \fBREPLY\fP\&.  \fIlist\fP is executed
for each selection until a break or end\-of\-file is encountered\&.
.TP
\fB(\fP \fIlist\fP \fB)\fP
Execute \fIlist\fP in a subshell\&.  Traps set by the \fBtrap\fP builtin
are reset to their default values while executing \fIlist\fP\&.
.TP
\fB{\fP \fIlist\fP \fB}\fP
Execute \fIlist\fP\&.
.TP
.PD 0
\fBfunction\fP \fIword\fP \&.\&.\&. [ \fB()\fP ] [ \fIterm\fP ] \fB{\fP \fIlist\fP \fB}\fP
.TP
.PD 0
\fIword\fP \&.\&.\&. \fB()\fP [ \fIterm\fP ] \fB{\fP \fIlist\fP \fB}\fP
.TP
.PD
\fIword\fP \&.\&.\&. \fB()\fP [ \fIterm\fP ] \fIcommand\fP
where \fIterm\fP is one or more newline or \fB;\fP\&.
Define a function which is referenced by any one of \fIword\fP\&.
Normally, only one \fIword\fP is provided; multiple \fIword\fPs
are usually only useful for setting traps\&.
The body of the function is the \fIlist\fP between
the \fB{\fP and \fB}\fP\&.  See the section `Functions'\&.
.RS
.PP
If the option \fBSH_GLOB\fP is set for compatibility with other shells, then
whitespace may appear between between the left and right parentheses when
there is a single \fIword\fP;  otherwise, the parentheses will be treated as
forming a globbing pattern in that case\&.
.RE
.TP
\fBtime\fP [ \fIpipeline\fP ]
The \fIpipeline\fP is executed, and timing statistics are
reported on the standard error in the form specified
by the \fBTIMEFMT\fP parameter\&.
If \fIpipeline\fP is omitted, print statistics about the
shell process and its children\&.
.TP
\fB[[\fP \fIexp\fP \fB]]\fP
Evaluates the conditional expression \fIexp\fP
and return a zero exit status if it is true\&.
See the section `Conditional Expressions'
for a description of \fIexp\fP\&.
.SH "ALTERNATE FORMS FOR COMPLEX COMMANDS"
Many of zsh's complex commands have alternate forms\&.  These particular
versions of complex commands should be considered deprecated and may be
removed in the future\&.  The versions in the previous section should be
preferred instead\&.
.PP
The short versions below only work if \fIsublist\fP is of the form `\fB{\fP
\fIlist\fP \fB}\fP' or if the \fBSHORT_LOOPS\fP option is set\&.  For the \fBif\fP,
\fBwhile\fP and \fBuntil\fP commands, in both these cases the test part of the
loop must also be suitably delimited, such as by `\fB[[ \&.\&.\&. ]]\fP' or `\fB((
\&.\&.\&. ))\fP', else the end of the test will not be recognized\&.  For the
\fBfor\fP, \fBrepeat\fP, \fBcase\fP and \fBselect\fP commands no such special form
for the arguments is necessary, but the other condition (the special form
of \fIsublist\fP or use of the \fBSHORT_LOOPS\fP option) still applies\&.
.PP
.PD 0
.TP
.PD
\fBif\fP \fIlist\fP \fB{\fP \fIlist\fP \fB}\fP [ \fBelif\fP \fIlist\fP \fB{\fP \fIlist\fP \fB}\fP ] \&.\&.\&. [ \fBelse {\fP \fIlist\fP \fB}\fP ]
An alternate form of \fBif\fP\&.  The rules mean that
.RS
.PP
.RS
.nf
\fBif [[ \-o ignorebraces ]] {
  print yes
}\fP
.fi
.RE
.PP
works, but
.PP
.RS
.nf
\fBif true {  # Does not work!
  print yes
}
\fP
.fi
.RE
.PP
does \fInot\fP, since the test is not suitably delimited\&.
.RE
.TP
\fBif\fP \fIlist\fP \fIsublist\fP
A short form of the alternate `if'\&.  The same limitations on the form of
\fIlist\fP apply as for the previous form\&.
.TP
\fBfor\fP \fIname\fP \fB(\fP \fIword\fP \&.\&.\&. \fB)\fP \fIsublist\fP
A short form of \fBfor\fP\&.
.TP
\fBfor\fP \fIname\fP [ \fBin\fP \fIword\fP \&.\&.\&. \fIterm\fP ] \fIsublist\fP
where \fIterm\fP is at least one newline or \fB;\fP\&.
Another short form of \fBfor\fP\&.
.TP
\fBfor ((\fP [\fIexpr1\fP] \fB;\fP [\fIexpr2\fP] \fB;\fP [\fIexpr3\fP] \fB))\fP \fIsublist\fP
A short form of the arithmetic \fBfor\fP command\&.
.TP
\fBforeach\fP \fIname\fP \fB(\fP \fIword\fP \&.\&.\&. \fB)\fP \fIlist\fP \fBend\fP
Another form of \fBfor\fP\&.
.TP
\fBwhile\fP \fIlist\fP \fB{\fP \fIlist\fP \fB}\fP
An alternative form of \fBwhile\fP\&.  Note the limitations on the form of
\fIlist\fP mentioned above\&.
.TP
\fBuntil\fP \fIlist\fP \fB{\fP \fIlist\fP \fB}\fP
An alternative form of \fBuntil\fP\&.  Note the limitations on the form of
\fIlist\fP mentioned above\&.
.TP
\fBrepeat\fP \fIword\fP \fIsublist\fP
This is a short form of \fBrepeat\fP\&.
.TP
\fBcase\fP \fIword\fP \fB{\fP [ [\fB(\fP] \fIpattern\fP [ \fB|\fP \fIpattern\fP ] \&.\&.\&. \fB)\fP \fIlist\fP (\fB;;\fP|\fB;&\fP) ] \&.\&.\&. \fB}\fP
An alternative form of \fBcase\fP\&.
.TP
\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP \fIterm\fP ] \fIsublist\fP
where \fIterm\fP is at least one newline or \fB;\fP\&.
A short form of \fBselect\fP\&.
.SH "RESERVED WORDS"
The following words are recognized as reserved words when used as the first
word of a command unless quoted or disabled using \fBdisable \-r\fP:
.PP
\fBdo done esac then elif else fi for case
if while function repeat time until
select coproc nocorrect foreach end ! [[ { }\fP
.PP
Additionally, `\fB}\fP' is recognized in any position if the \fBIGNORE_BRACES\fP option
is not set\&.
.SH "COMMENTS"
In noninteractive shells, or in interactive shells with the
\fBINTERACTIVE_COMMENTS\fP option set, a word beginning
with the third character of the \fBhistchars\fP parameter
(`\fB#\fP' by default) causes that word and all the following
characters up to a newline to be ignored\&.
.SH "ALIASING"
Every token in the shell input is checked to see if there
is an alias defined for it\&.
If so, it is replaced by the text of the alias if it is in command
position (if it could be the first word of a simple command),
or if the alias is global\&.
If the text ends with a space, the next word in the shell input
is treated as though it were in command position for purposes of alias
expansion\&.
An alias is defined using the \fBalias\fP builtin; global aliases
may be defined using the \fB\-g\fP option to that builtin\&.
.PP
Alias expansion is done on the shell input before any
other expansion except history expansion\&.  Therefore,
if an alias is defined for the word \fBfoo\fP, alias expansion
may be avoided by quoting part of the word, e\&.g\&. \fB\efoo\fP\&.
But there is nothing to prevent an alias being defined
for \fB\efoo\fP as well\&.
.SH "QUOTING"
A character may be \fIquoted\fP (that is, made
to stand for itself) by preceding it with a `\fB\e\fP'\&.
`\fB\e\fP' followed by a newline is ignored\&.
.PP
A string enclosed between `\fB$'\fP' and `\fB'\fP' is
processed the same way as the string arguments of the
\fBprint\fP builtin, and the resulting string is considered to be
entirely quoted\&.  A literal `\fB'\fP' character can be included in the
string by using the `\fB\e'\fP' escape\&.
.PP
All characters enclosed between a pair of single quotes (\fB''\fP) that
is not preceded by a `\fB$\fP' are quoted\&.  A single quote cannot appear
within single quotes unless the option \fBRC_QUOTES\fP is set, in which case
a pair of single quotes are turned into a single quote\&.  For example,
.PP
.RS
.nf
\fBprint ''''\fP
.fi
.RE
.PP
outputs nothing apart from a newline if \fBRC_QUOTES\fP is not set, but one
single quote if it is set\&.
.PP
Inside double quotes (\fB""\fP), parameter and
command substitution occur, and `\fB\e\fP' quotes the characters
`\fB\e\fP', `\fB`\fP', `\fB"\fP', and `\fB$\fP'\&.
.\" Yodl file: Zsh/redirect.yo
.SH "REDIRECTION"
If a command is followed by \fB&\fP
and job control is not active,
then the default standard input
for the command is the empty file \fB/dev/null\fP\&.
Otherwise, the environment for the execution of a command contains the
file descriptors of the invoking shell as modified by
input/output specifications\&.
.PP
The following may appear anywhere in a simple command
or may precede or follow a complex command\&.
Expansion occurs before \fIword\fP or \fIdigit\fP
is used except as noted below\&.
If the result of substitution on \fIword\fP
produces more than one filename,
redirection occurs for each
separate filename in turn\&.
.PP
.PD 0
.TP
.PD
\fB<\fP \fIword\fP
Open file \fIword\fP for reading as standard input\&.
.TP
\fB<>\fP \fIword\fP
Open file \fIword\fP for reading and writing as standard input\&.
If the file does not exist then it is created\&.
.TP
\fB>\fP \fIword\fP
Open file \fIword\fP for writing as standard output\&.
If the file does not exist then it is created\&.
If the file exists, and the \fBCLOBBER\fP option is unset,
this causes an error;
otherwise, it is truncated to zero length\&.
.TP
.PD 0
\fB>|\fP \fIword\fP
.TP
.PD
\fB>!\fP \fIword\fP
Same as \fB>\fP, except that the file is truncated to zero length
if it exists, even if \fBCLOBBER\fP is unset\&.
.TP
\fB>>\fP \fIword\fP
Open file \fIword\fP for writing in append mode as standard output\&.
If the file does not exist, and the \fBCLOBBER\fP
option is unset, this causes an error;
otherwise, the file is created\&.
.TP
.PD 0
\fB>>|\fP \fIword\fP
.TP
.PD
\fB>>!\fP \fIword\fP
Same as \fB>>\fP, except that the file is created if it does not
exist, even if \fBCLOBBER\fP is unset\&.
.TP
\fB<<\fP[\fB\-\fP] \fIword\fP
The shell input is read up to a line that is the same as
\fIword\fP, or to an end\-of\-file\&.
No parameter expansion, command substitution or
filename generation is performed on \fIword\fP\&.
The resulting document, called a
\fIhere\-document\fP, becomes the standard input\&.
.RS
.PP
If any character of \fIword\fP is quoted with
single or double quotes or a `\fB\e\fP',
no interpretation is placed upon the characters of the document\&.
Otherwise, parameter and command substitution
occurs, `\fB\e\fP' followed by a newline is removed,
and `\fB\e\fP' must be used to quote the characters
`\fB\e\fP', `\fB$\fP', `\fB`\fP' and the first character of \fIword\fP\&.
.PP
If \fB<<\-\fP is used, then all leading
tabs are stripped from \fIword\fP and from the document\&.
.RE
.TP
\fB<<<\fP \fIword\fP
Perform shell expansion on \fIword\fP and pass the result
to standard input\&.  This is known as a \fIhere\-string\fP\&.
.TP
.PD 0
\fB<&\fP \fInumber\fP
.TP
.PD
\fB>&\fP \fInumber\fP
The standard input/output is duplicated from file descriptor
\fInumber\fP (see \fIdup2\fP(2))\&.
.TP
.PD 0
\fB<& \-\fP
.TP
.PD
\fB>& \-\fP
Close the standard input/output\&.
.TP
.PD 0
\fB<& p\fP
.TP
.PD
\fB>& p\fP
The input/output from/to the coprocess is moved to the standard input/output\&.
.TP
.PD 0
\fB>&\fP \fIword\fP
.TP
.PD
\fB&>\fP \fIword\fP
(Except where `\fB>&\fP \fIword\fP' matches one of the above syntaxes;
`\fB&>\fP' can always be used to avoid this ambiguity\&.)
Redirects both standard output and standard error (file descriptor 2)
in the manner of `\fB>\fP \fIword\fP'\&.
Note that this does \fInot\fP have the same effect as `\fB>\fP \fIword\fP \fB2>&1\fP'
in the presence of multios (see the section below)\&.
.TP
.PD 0
\fB>&|\fP \fIword\fP
.TP
.PD 0
\fB>&!\fP \fIword\fP
.TP
.PD 0
\fB&>|\fP \fIword\fP
.TP
.PD
\fB&>!\fP \fIword\fP
Redirects both standard output and standard error (file descriptor 2)
in the manner of `\fB>|\fP \fIword\fP'\&.
.TP
.PD 0
\fB>>&\fP \fIword\fP
.TP
.PD
\fB&>>\fP \fIword\fP
Redirects both standard output and standard error (file descriptor 2)
in the manner of `\fB>>\fP \fIword\fP'\&.
.TP
.PD 0
\fB>>&|\fP \fIword\fP
.TP
.PD 0
\fB>>&!\fP \fIword\fP
.TP
.PD 0
\fB&>>|\fP \fIword\fP
.TP
.PD
\fB&>>!\fP \fIword\fP
Redirects both standard output and standard error (file descriptor 2)
in the manner of `\fB>>|\fP \fIword\fP'\&.
.PP
If one of the above is preceded by a digit, then the file
descriptor referred to is that specified by the digit
instead of the default 0 or 1\&.
The order in which redirections are specified is significant\&.
The shell evaluates each redirection in terms of the
(\fIfile descriptor\fP, \fIfile\fP)
association at the time of evaluation\&.
For example:
.PP
.RS
.nf
\&.\&.\&. \fB1>\fP\fIfname\fP \fB2>&1\fP
.fi
.RE
.PP
first associates file descriptor 1 with file \fIfname\fP\&.
It then associates file descriptor 2 with the file associated with file
descriptor 1 (that is, \fIfname\fP)\&.
If the order of redirections were reversed,
file descriptor 2 would be associated
with the terminal (assuming file descriptor 1 had been)
and then file descriptor 1 would be associated with file \fIfname\fP\&.
.SH "MULTIOS"
If the user tries to open a file descriptor for writing more than once,
the shell opens the file descriptor as a pipe to a process that copies
its input to all the specified outputs, similar to \fBtee\fP,
provided the \fBMULTIOS\fP option is set, as it is by default\&.  Thus:
.PP
.RS
.nf
\fBdate >foo >bar\fP
.fi
.RE
.PP
writes the date to two files, named `\fBfoo\fP' and `\fBbar\fP'\&.
Note that a pipe is an implicit redirection; thus
.PP
.RS
.nf
\fBdate >foo | cat\fP
.fi
.RE
.PP
writes the date to the file `\fBfoo\fP', and also pipes it to cat\&.
.PP
If the \fBMULTIOS\fP
option is set, the word after a redirection operator is also subjected
to filename generation (globbing)\&.  Thus
.PP
.RS
.nf
\fB: > *\fP
.fi
.RE
.PP
will truncate all files in the current directory,
assuming there's at least one\&.  (Without the \fBMULTIOS\fP
option, it would create an empty file called `\fB*\fP'\&.)
Similarly, you can do
.PP
.RS
.nf
\fBecho exit 0 >> *\&.sh\fP
.fi
.RE
.PP
If the user tries to open a file descriptor for reading more than once,
the shell opens the file descriptor as a pipe to a process that copies
all the specified inputs to its output in the order
specified, similar to \fBcat\fP,
provided the \fBMULTIOS\fP option is set\&.  Thus
.PP
.RS
.nf
\fBsort <foo <fubar\fP
.fi
.RE
.PP
or even
.PP
.RS
.nf
\fBsort <f{oo,ubar}\fP
.fi
.RE
.PP
is equivalent to `\fBcat foo fubar | sort\fP'\&.
.PP
Note that a pipe is an implicit redirection; thus
.PP
.RS
.nf
\fBcat bar | sort <foo\fP
.fi
.RE
.PP
is equivalent to `\fBcat bar foo | sort\fP' (note the order of the inputs)\&.
.PP
If the \fBMULTIOS\fP option is \fIun\fPset,
each redirection replaces the previous redirection for that file descriptor\&.
However, all files redirected to are actually opened, so
.PP
.RS
.nf
\fBecho foo > bar > baz\fP
.fi
.RE
.PP
when \fBMULTIOS\fP is unset will truncate bar, and write `\fBfoo\fP' into baz\&.
.PP
.SH "REDIRECTIONS WITH NO COMMAND"
When a simple command consists of one or more redirection operators
and zero or more parameter assignments, but no command name, zsh can
behave in several ways\&.
.PP
If the parameter \fBNULLCMD\fP is not set or the option \fBCSH_NULLCMD\fP is
set, an error is caused\&.  This is the \fBcsh\fP behavior and \fBCSH_NULLCMD\fP
is set by default when emulating \fBcsh\fP\&.
.PP
If the option \fBSH_NULLCMD\fP is set, the builtin `\fB:\fP' is inserted as a
command with the given redirections\&.  This is the default when emulating
\fBsh\fP or \fBksh\fP\&.
.PP
Otherwise, if the parameter \fBNULLCMD\fP is set, its value will be used as a
command with the given redirections\&.  If both \fBNULLCMD\fP and
\fBREADNULLCMD\fP are set, then the value of the latter will be used instead
of that of the former when the redirection is an input\&.  The default for
\fBNULLCMD\fP is `\fBcat\fP' and for \fBREADNULLCMD\fP is `\fBmore\fP'\&. Thus
.PP
.RS
.nf
\fB< file\fP
.fi
.RE
.PP
shows the contents of \fBfile\fP on standard output, with paging if that is a
terminal\&.  \fBNULLCMD\fP and \fBREADNULLCMD\fP may refer to shell functions\&.
.PP
.\" Yodl file: Zsh/exec.yo
.SH "COMMAND EXECUTION"
If a command name contains no slashes, the shell attempts to locate
it\&.  If there exists a shell function by that name, the function
is invoked as described in the section `Functions'\&.  If there exists
a shell builtin by that name, the builtin is invoked\&.
.PP
Otherwise, the shell searches each element of \fB$path\fP for a
directory containing an executable file by that name\&.  If the
search is unsuccessful, the shell prints an error message and returns
a nonzero exit status\&.
.PP
If execution fails because the file is not in executable format,
and the file is not a directory, it is assumed to be a shell
script\&.  \fB/bin/sh\fP is spawned to execute it\&.  If the program
is a file beginning with `\fB#!\fP', the remainder of the first line
specifies an interpreter for the program\&.  The shell will
execute the specified interpreter on operating systems that do
not handle this executable format in the kernel\&.
.\" Yodl file: Zsh/func.yo
.SH "FUNCTIONS"
Shell functions are defined with the \fBfunction\fP reserved word or the
special syntax `\fIfuncname\fP \fB()\fP'\&.
Shell functions are read in and stored internally\&.
Alias names are resolved when the function is read\&.
Functions are executed like commands with the arguments
passed as positional parameters\&.
(See the section `Command Execution'\&.)
.PP
Functions execute in the same process as the caller and
share all files
and present working directory with the
caller\&.  A trap on \fBEXIT\fP set inside a function
is executed after the function completes in the environment
of the caller\&.
.PP
The \fBreturn\fP builtin is used to return from function calls\&.
.PP
Function identifiers can be listed with the \fBfunctions\fP builtin\&.
Functions can be undefined with the \fBunfunction\fP builtin\&.
.SH "AUTOLOADING FUNCTIONS"
.PP
A function can be marked as \fIundefined\fP using the \fBautoload\fP builtin
(or `\fBfunctions \-u\fP' or `\fBtypeset \-fu\fP')\&.  Such a function has no
body\&.  When the function is first executed, the shell searches for its
definition using the elements of the \fBfpath\fP variable\&.  Thus to define
functions for autoloading, a typical sequence is:
.PP
.RS
.nf
\fBfpath=(~/myfuncs $fpath)
autoload myfunc1 myfunc2 \&.\&.\&.\fP
.fi
.RE
.PP
The usual alias expansion during reading will be suppressed if the
\fBautoload\fP builtin or its equivalent is given the option \fB\-U\fP\&. This is
recommended for the use of functions supplied with the zsh distribution\&.
Note that for functions precompiled with the \fBzcompile\fP builtin command
the flag \fB\-U\fP must be provided when the \fB\&.zwc\fP file is created, as the
corresponding information is compiled into the latter\&.
.PP
For each \fIelement\fP in \fBfpath\fP, the shell looks for three possible
files, the newest of which is used to load the definition for the function:
.PP
.PD 0
.TP
.PD
\fIelement\fP\fB\&.zwc\fP
A file created with the \fBzcompile\fP builtin command, which is expected to
contain the definitions for all functions in the directory named
\fIelement\fP\&.  The file is treated in the same manner as a directory
containing files for functions and is searched for the definition of the
function\&.   If the definition is not found, the search for a definition
proceeds with the other two possibilities described below\&.
.RS
.PP
If \fIelement\fP already includes a \fB\&.zwc\fP extension (i\&.e\&. the extension
was explicitly given by the user), \fIelement\fP is searched for the
definition of the function without comparing its age to that of other
files; in fact, there does not need to be any directory named \fIelement\fP
without the suffix\&.  Thus including an element such as
`\fB/usr/local/funcs\&.zwc\fP' in \fBfpath\fP will speed up the search for
functions, with the disadvantage that functions included must be explicitly
recompiled by hand before the shell notices any changes\&.
.RE
.TP
\fIelement\fP\fB/\fP\fIfunction\fP\fB\&.zwc\fP
A file created with \fBzcompile\fP, which is expected to contain the
definition for \fIfunction\fP\&.  It may include other function definitions
as well, but those are neither loaded nor executed; a file found in this
way is searched \fIonly\fP for the definition of \fIfunction\fP\&.
.TP
\fIelement\fP\fB/\fP\fIfunction\fP
A file of zsh command text, taken to be the definition for \fIfunction\fP\&.
.PP
In summary, the order of searching is, first, in the \fIparents of\fP
directories in \fBfpath\fP for the newer of either a compiled directory or
a directory in \fBfpath\fP; second, if more than one of these contains a
definition for the function that is sought, the leftmost in the \fBfpath\fP
is chosen; and third, within a directory, the newer of either a compiled
function or an ordinary function definition is used\&.
.PP
If the \fBKSH_AUTOLOAD\fP option is set, or the file contains only a
simple definition of the function, the file's contents will be executed\&.
This will normally define the function in question, but may also perform
initialization, which is executed in the context of the function execution,
and may therefore define local parameters\&.  It is an error if the function
is not defined by loading the file\&.
.PP
Otherwise, the function body (with no surrounding `\fIfuncname\fP\fB()
{\fP\fI\&.\&.\&.\fP\fB}\fP') is taken to be the complete contents of the file\&.  This
form allows the file to be used directly as an executable shell script\&.  If
processing of the file results in the function being re\-defined, the
function itself is not re\-executed\&.  To force the shell to perform
initialization and then call the function defined, the file should contain
initialization code (which will be executed then discarded) in addition to
a complete function definition (which will be retained for subsequent calls
to the function), and a call to the shell function, including any
arguments, at the end\&.
.PP
For example, suppose the autoload file \fBfunc\fP contains
.PP
.RS
.nf
\fBfunc() { print This is func; }
print func is initialized
\fP
.fi
.RE
.PP
then `\fBfunc; func\fP' with \fBKSH_AUTOLOAD\fP set will produce both messages
on the first call, but only the message `\fBThis is func\fP' on the second
and subsequent calls\&.  Without \fBKSH_AUTOLOAD\fP set, it will produce
the initialization message on the first call, and the other message on the
second and subsequent calls\&.
.PP
It is also possible to create a function that is not marked as autoloaded,
but which loads its own definition by searching \fBfpath\fP, by using
`\fBautoload \-X\fP' within a shell function\&.  For example, the following are
equivalent:
.PP
.RS
.nf
\fBmyfunc() {
  autoload \-X
}
myfunc args\&.\&.\&.\fP
.fi
.RE
.PP
and
.PP
.RS
.nf
\fBunfunction myfunc   # if myfunc was defined
autoload myfunc
myfunc args\&.\&.\&.\fP
.fi
.RE
.PP
In fact, the \fBfunctions\fP command outputs `\fBbuiltin autoload \-X\fP' as
the body of an autoloaded function\&.  A true autoloaded function can be
identified by the presence of the comment `\fB# undefined\fP' in the body,
because all comments are discarded from defined functions\&.  This is done
so that
.PP
.RS
.nf
\fBeval "$(functions)"\fP
.fi
.RE
.PP
produces a reasonable result\&.
.PP
To load the definition of an autoloaded function \fBmyfunc\fP without
executing \fBmyfunc\fP, use:
.PP
.RS
.nf
\fBautoload +X myfunc\fP
.fi
.RE
.PP
.SH "SPECIAL FUNCTIONS"
The following functions, if defined, have special meaning to
the shell:
.PP
.PD 0
.TP
.PD
\fBchpwd\fP
Executed whenever the current working directory is changed\&.
.TP
\fBperiodic\fP
If the parameter \fBPERIOD\fP
is set, this function is executed every \fB$PERIOD\fP
seconds, just before a prompt\&.
.TP
\fBprecmd\fP
Executed before each prompt\&.
.TP
\fBpreexec\fP
Executed just after a command has been read and is about to be
executed\&.  If the history mechanism is active (and the line was not
discarded from the history buffer), the string that the user typed is
passed as the first argument, otherwise it is an empty string\&.  The
actual command that will be executed (including expanded aliases) is
passed in two different forms: the second argument is a single\-line,
size\-limited version of the command (with things like function bodies
elided); the third argument contains the full text what what is being
executed\&.
.TP
\fBTRAP\fP\fINAL\fP
If defined and non\-null,
this function will be executed whenever the shell
catches a signal \fBSIG\fP\fINAL\fP, where \fINAL\fP is a signal
name as specified for the \fBkill\fP builtin\&.
The signal number will be passed as the first parameter to the function\&.
.RS
.PP
If a function of this form is defined and null,
the shell and processes spawned by it will ignore \fBSIG\fP\fINAL\fP\&.
.RE
.TP
\fBTRAPDEBUG\fP
Executed after each command\&.
.TP
\fBTRAPEXIT\fP
Executed when the shell exits,
or when the current function exits if defined inside a function\&.
.TP
\fBTRAPZERR\fP
Executed whenever a command has a non\-zero exit status\&.  However, the
function is not executed if the command occurred in a sublist followed by
`\fB&&\fP' or `\fB||\fP'; only the final command in a sublist of this type
causes the trap to be executed\&.
.PP
The functions beginning `\fBTRAP\fP' may alternatively be defined with the
\fBtrap\fP builtin:  this may be preferable for some uses, as they are then
run in the environment of the calling process, rather than in their own
function environment\&.  Apart from the difference in calling procedure and
the fact that the function form appears in lists of functions, the forms
.PP
.RS
.nf
\fBTRAPNAL() { 
 # code
}\fP
.fi
.RE
.PP
and
.PP
.RS
.nf
\fBtrap '
 # code
' NAL\fP
.fi
.RE
.PP
are equivalent\&.
.\" Yodl file: Zsh/jobs.yo
.SH "JOBS"
If the \fBMONITOR\fP option is set,
an interactive shell associates a \fIjob\fP with each pipeline\&.
It keeps a table of current jobs, printed by the \fBjobs\fP
command, and assigns them small integer numbers\&.
When a job is started asynchronously with `\fB&\fP',
the shell prints a line which looks like:
.PP
.RS
.nf
\fB[1] 1234\fP
.fi
.RE
.PP
indicating that the job which was started asynchronously was job number
1 and had one (top\-level) process, whose process ID was 1234\&.
.PP
If a job is started with `\fB&|\fP' or `\fB&!\fP',
then that job is immediately disowned\&.  After startup, it
does not have a place in the job table, and is not subject
to the job control features described here\&.
.PP
If you are running a job and wish to do something else you may hit the key
^Z (control\-Z) which sends a \fBTSTP\fP signal to the current job:  this key
may be redefined by the \fBsusp\fP option of the external \fBstty\fP command\&.
The shell will then normally indicate that the job has been `suspended',
and print another prompt\&.  You can then manipulate the state of this job,
putting it in the background with the \fBbg\fP command, or run some other
commands and then eventually bring the job back into the foreground with
the foreground command \fBfg\fP\&.  A ^Z takes effect immediately and
is like an interrupt in that pending output and unread input are discarded
when it is typed\&.
.PP
A job being run in the background will suspend if it tries to read
from the terminal\&.
Background jobs are normally allowed to produce output,
but this can be disabled by giving the command `\fBstty tostop\fP'\&.
If you set this
tty option, then background jobs will suspend when they try to produce
output like they do when they try to read input\&.
.PP
When a command is suspended and continued later with the \fBfg\fP or
\fBwait\fP builtins, zsh restores tty modes that were in effect when it was
suspended\&.  This (intentionally) does not apply if the command is
continued via `\fBkill \-CONT\fP', nor when it is continued with \fBbg\fP\&.
.PP
There are several ways to refer to jobs in the shell\&.
A job can be referred to by the process ID of any process of the job
or by one of the following:
.PP
.PD 0
.TP
\fB%\fP\fInumber\fP
The job with the given number\&.
.TP
\fB%\fP\fIstring\fP
Any job whose command line begins with \fIstring\fP\&.
.TP
\fB%?\fP\fIstring\fP
Any job whose command line contains \fIstring\fP\&.
.TP
\fB%%\fP
Current job\&.
.TP
\fB%+\fP
Equivalent to `\fB%%\fP'\&.
.TP
\fB%\-\fP
Previous job\&.
.PD
.PP
The shell learns immediately whenever a process changes state\&.
It normally informs you whenever a job becomes blocked so that
no further progress is possible\&.  If the \fBNOTIFY\fP option is not set,
it waits until just before it prints a prompt before it informs you\&.
.PP
When the monitor mode is on, each background job that completes
triggers any trap set for \fBCHLD\fP\&.
.PP
When you try to leave the shell while jobs are running or suspended, you will
be warned that `You have suspended (running) jobs'\&.
You may use the \fBjobs\fP command to see what they are\&.
If you do this or immediately try to
exit again, the shell will not warn you a second time; the suspended
jobs will be terminated, and the running jobs will be sent
a \fBSIGHUP\fP signal, if the \fBHUP\fP option is set\&.
.PP
To avoid having the shell terminate the running jobs, either
use the \fBnohup\fP command (see \fInohup\fP(1))
or the \fBdisown\fP builtin\&.
.SH "SIGNALS"
The \fBINT\fP and \fBQUIT\fP signals for an invoked
command are ignored if the command is followed by
`\fB&\fP' and the \fBMONITOR\fP option is not active\&.
Otherwise, signals have the values
inherited by the shell from its parent
(but see the \fBTRAP\fP\fINAL\fP special functions in the section `Functions')\&.
.\" Yodl file: Zsh/arith.yo
.SH "ARITHMETIC EVALUATION"
The shell can perform integer and floating point arithmetic, either using
the builtin \fBlet\fP, or via a substitution of the form \fB$((\&.\&.\&.))\fP\&.  For
integers, the shell is usually compiled to use 8\-byte precision where this
is available, otherwise precision is 4 bytes\&.  This can be tested, for
example, by giving the command `\fBprint \- $(( 12345678901 ))\fP'; if the
number appears unchanged, the precision is at least 8 bytes\&.  Floating
point arithmetic is always double precision\&.
.PP
The \fBlet\fP builtin command takes arithmetic expressions as arguments; each
is evaluated separately\&.  Since many of the arithmetic operators, as well
as spaces, require quoting, an alternative form is provided: for any
command which begins with a `\fB((\fP', all the characters until a
matching `\fB))\fP' are treated as a quoted expression and
arithmetic expansion performed as for an argument of \fBlet\fP\&.  More
precisely, `\fB((\fP\fI\&.\&.\&.\fP\fB))\fP' is equivalent to
`\fBlet "\fP\fI\&.\&.\&.\fP\fB"\fP'\&.  For example, the following statement
.PP
.RS
.nf
\fB(( val = 2 + 1 ))\fP
.fi
.RE
.PP
is equivalent to
.PP
.RS
.nf
\fBlet "val = 2 + 1"\fP
.fi
.RE
.PP
both assigning the value 3 to the shell variable \fBval\fP and returning a
zero status\&.
.PP
Integers can be in bases other than 10\&.
A leading `\fB0x\fP' or `\fB0X\fP' denotes hexadecimal\&.
Integers may also be of the form `\fIbase\fP\fB#\fP\fIn\fP',
where \fIbase\fP is a decimal number between two and thirty\-six
representing the arithmetic base and \fIn\fP
is a number in that base (for example, `\fB16#ff\fP' is 255 in hexadecimal)\&.
The \fIbase\fP\fB#\fP may also be omitted, in which case
base 10 is used\&.  For backwards compatibility the form
`\fB[\fP\fIbase\fP\fB]\fP\fIn\fP' is also accepted\&.
.PP
It is also possible to specify a base to be used for output in the form
`\fB[#\fP\fIbase\fP\fB]\fP', for example `\fB[#16]\fP'\&.  This is used when
outputting arithmetical substitutions or when assigning to scalar
parameters, but an explicitly defined integer or floating point parameter
will not be affected\&.  If an integer variable is implicitly defined by an
arithmetic expression, any base specified in this way will be set as the
variable's output arithmetic base as if the option `\fB\-i\fP \fIbase\fP' to
the \fBtypeset\fP builtin had been used\&.  The expression has no precedence
and if it occurs more than once in a mathematical expression, the last
encountered is used\&.  For clarity it is recommended that it appear at the
beginning of an expression\&.  As an example:
.PP
.RS
.nf
\fBtypeset \-i 16 y
print $(( [#8] x = 32, y = 32 ))
print $x $y\fP
.fi
.RE
.PP
outputs first `\fB8#40\fP', the rightmost value in the given output base, and
then `\fB8#40 16#20\fP', because \fBy\fP has been explicitly declared to
have output base 16, while \fBx\fP (assuming it does not already exist) is
implicitly typed by the arithmetic evaluation, where it acquires the output
base 8\&.
.PP
When an output base is specified using the `\fB[#\fP\fIbase\fP\fB]\fP' syntax,
an appropriate base prefix will be output if necessary, so that the value
output is valid syntax for input\&.  If the \fB#\fP is doubled, for example
`\fB[##16]\fP', then no base prefix is output\&.
.PP
Floating point constants are recognized by the presence of a decimal point
or an exponent\&.  The decimal point may be the first character of the
constant, but the exponent character \fBe\fP or \fBE\fP may not, as it will be
taken for a parameter name\&.
.PP
An arithmetic expression uses nearly the same syntax, precedence, and
associativity of expressions in C\&.
The following operators are supported (listed in decreasing order
of precedence):
.PP
.PD 0
.TP
\fB+ \- ! ~ ++ \-\-\fP
unary plus/minus, logical NOT, complement, {pre,post}{in,de}crement
.TP
\fB<< >>\fP
bitwise shift left, right
.TP
\fB&\fP
bitwise AND
.TP
\fB^\fP
bitwise XOR
.TP
\fB|\fP
bitwise OR
.TP
\fB**\fP
exponentiation
.TP
\fB* / %\fP
multiplication, division, modulus (remainder)
.TP
\fB+ \-\fP
addition, subtraction
.TP
\fB< > <= >=\fP
comparison
.TP
\fB== !=\fP
equality and inequality
.TP
\fB&&\fP
logical AND
.TP
\fB|| ^^\fP
logical OR, XOR
.TP
\fB? :\fP
ternary operator
.TP
\fB= += \-= *= /= %= &= ^= |= <<= >>= &&= ||= ^^= **=\fP
assignment
.TP
\fB,\fP
comma operator
.PD
.PP
The operators `\fB&&\fP', `\fB||\fP', `\fB&&=\fP', and `\fB||=\fP' are
short\-circuiting, and only one of the latter two expressions in a ternary
operator is evaluated\&.  Note the precedence of the bitwise AND, OR,
and XOR operators\&.
.PP
Mathematical functions can be called with the syntax
`\fIfunc\fP\fB(\fP\fIargs\fP\fB)\fP', where the function decides
if the \fIargs\fP is used as a string or a comma\-separated list of
arithmetic expressions\&. The shell currently defines no mathematical
functions by default, but the module \fBzsh/mathfunc\fP may be loaded with
the \fBzmodload\fP builtin to provide standard floating point mathematical
functions\&.
.PP
An expression of the form `\fB##\fP\fIx\fP' where \fIx\fP is any character
sequence such as `\fBa\fP', `\fB^A\fP', or `\fB\eM\-\eC\-x\fP' gives the ASCII
value of this character and an expression of the form `\fB#\fP\fIfoo\fP'
gives the ASCII value of the first character of the value of the
parameter \fIfoo\fP\&.  Note that this is different from the expression
`\fB$#\fP\fIfoo\fP', a standard parameter substitution which gives the
length of the parameter \fIfoo\fP\&.  `\fB#\e\fP' is accepted instead of
`\fB##\fP', but its use is deprecated\&.
.PP
Named parameters and subscripted arrays can be referenced by name within an
arithmetic expression without using the parameter expansion syntax\&.  For
example,
.PP
.RS
.nf
\fB((val2 = val1 * 2))\fP
.fi
.RE
.PP
assigns twice the value of \fB$val1\fP to the parameter named \fBval2\fP\&.
.PP
An internal integer representation of a named parameter
can be specified with the \fBinteger\fP builtin\&.
Arithmetic evaluation is performed on the value of each
assignment to a named parameter declared integer
in this manner\&.  Assigning a floating point number to an integer results in
rounding down to the next integer\&.
.PP
Likewise, floating point numbers can be declared with the \fBfloat\fP
builtin; there are two types, differing only in their output format, as
described for the \fBtypeset\fP builtin\&.  The output format can be bypassed
by using arithmetic substitution instead of the parameter substitution,
i\&.e\&. `\fB${\fP\fIfloat\fP\fB}\fP' uses the defined format, but
`\fB$((\fP\fIfloat\fP\fB))\fP' uses a generic floating point
format\&.
.PP
Promotion of integer to floating point values is performed where
necessary\&.  In addition, if any operator which requires an integer
(`\fB~\fP', `\fB&\fP', `\fB|\fP', `\fB^\fP', `\fB%\fP', `\fB<<\fP', `\fB>>\fP' and their
equivalents with assignment) is given a floating point argument, it will be
silently rounded down to the next integer\&.
.PP
Scalar variables can hold integer or floating point values at different
times; there is no memory of the numeric type in this case\&.
.PP
If a variable is first assigned in a numeric context without previously
being declared, it will be implicitly typed as \fBinteger\fP or \fBfloat\fP and
retain that type either until the type is explicitly changed or until the
end of the scope\&.  This can have unforeseen consequences\&.  For example, in
the loop
.PP
.RS
.nf
\fBfor (( f = 0; f < 1; f += 0\&.1 )); do
# use $f
done\fP
.fi
.RE
.PP
if \fBf\fP has not already been declared, the first assignment will cause it
to be created as an integer, and consequently the operation `\fBf += 0\&.1\fP'
will always cause the result to be truncated to zero, so that the loop will
fail\&.  A simple fix would be to turn the initialization into `\fBf = 0\&.0\fP'\&.
It is therefore best to declare numeric variables with explicit types\&.
.\" Yodl file: Zsh/cond.yo
.SH "CONDITIONAL EXPRESSIONS"
A \fIconditional expression\fP is used with the \fB[[\fP
compound command to test attributes of files and to compare strings\&.
Each expression can be constructed from one or more
of the following unary or binary expressions:
.PP
.PD 0
.TP
.PD
\fB\-a\fP \fIfile\fP
true if \fIfile\fP exists\&.
.TP
\fB\-b\fP \fIfile\fP
true if \fIfile\fP exists and is a block special file\&.
.TP
\fB\-c\fP \fIfile\fP
true if \fIfile\fP exists and is a character special file\&.
.TP
\fB\-d\fP \fIfile\fP
true if \fIfile\fP exists and is a directory\&.
.TP
\fB\-e\fP \fIfile\fP
true if \fIfile\fP exists\&.
.TP
\fB\-f\fP \fIfile\fP
true if \fIfile\fP exists and is a regular file\&.
.TP
\fB\-g\fP \fIfile\fP
true if \fIfile\fP exists and has its setgid bit set\&.
.TP
\fB\-h\fP \fIfile\fP
true if \fIfile\fP exists and is a symbolic link\&.
.TP
\fB\-k\fP \fIfile\fP
true if \fIfile\fP exists and has its sticky bit set\&.
.TP
\fB\-n\fP \fIstring\fP
true if length of \fIstring\fP is non\-zero\&.
.TP
\fB\-o\fP \fIoption\fP
true if option named \fIoption\fP is on\&.  \fIoption\fP
may be a single character, in which case it is a single letter option name\&.
(See the section `Specifying Options'\&.)
.TP
\fB\-p\fP \fIfile\fP
true if \fIfile\fP exists and is a FIFO special file (named pipe)\&.
.TP
\fB\-r\fP \fIfile\fP
true if \fIfile\fP exists and is readable by current process\&.
.TP
\fB\-s\fP \fIfile\fP
true if \fIfile\fP exists and has size greater than zero\&.
.TP
\fB\-t\fP \fIfd\fP
true if file descriptor number \fIfd\fP
is open and associated with a terminal device\&.
(note: \fIfd\fP is not optional)
.TP
\fB\-u\fP \fIfile\fP
true if \fIfile\fP exists and has its setuid bit set\&.
.TP
\fB\-w\fP \fIfile\fP
true if \fIfile\fP exists and is writable by current process\&.
.TP
\fB\-x\fP \fIfile\fP
true if \fIfile\fP exists and is executable by current process\&.
If \fIfile\fP exists and is a directory, then the current process
has permission to search in the directory\&.
.TP
\fB\-z\fP \fIstring\fP
true if length of \fIstring\fP is zero\&.
.TP
\fB\-L\fP \fIfile\fP
true if \fIfile\fP exists and is a symbolic link\&.
.TP
\fB\-O\fP \fIfile\fP
true if \fIfile\fP exists and is owned by the effective user ID of this process\&.
.TP
\fB\-G\fP \fIfile\fP
true if \fIfile\fP exists and its group matches
the effective group ID of this process\&.
.TP
\fB\-S\fP \fIfile\fP
true if \fIfile\fP exists and is a socket\&.
.TP
\fB\-N\fP \fIfile\fP
true if \fIfile\fP exists and its access time is
not newer than its modification time\&.
.TP
\fIfile1\fP \fB\-nt\fP \fIfile2\fP
true if \fIfile1\fP exists and is newer than \fIfile2\fP\&.
.TP
\fIfile1\fP \fB\-ot\fP \fIfile2\fP
true if \fIfile1\fP exists and is older than \fIfile2\fP\&.
.TP
\fIfile1\fP \fB\-ef\fP \fIfile2\fP
true if \fIfile1\fP and \fIfile2\fP exist and refer to the same file\&.
.TP
.PD 0
\fIstring\fP \fB=\fP \fIpattern\fP
.TP
.PD
\fIstring\fP \fB==\fP \fIpattern\fP
true if \fIstring\fP matches \fIpattern\fP\&.
The `\fB==\fP' form is the preferred one\&.  The `\fB=\fP' form is for
backward compatibility and should be considered obsolete\&.
.TP
\fIstring\fP \fB!=\fP \fIpattern\fP
true if \fIstring\fP does not match \fIpattern\fP\&.
.TP
\fIstring1\fP \fB<\fP \fIstring2\fP
true if \fIstring1\fP comes before \fIstring2\fP
based on ASCII value of their characters\&.
.TP
\fIstring1\fP \fB>\fP \fIstring2\fP
true if \fIstring1\fP comes after \fIstring2\fP
based on ASCII value of their characters\&.
.TP
\fIexp1\fP \fB\-eq\fP \fIexp2\fP
true if \fIexp1\fP is numerically equal to \fIexp2\fP\&.
.TP
\fIexp1\fP \fB\-ne\fP \fIexp2\fP
true if \fIexp1\fP is numerically not equal to \fIexp2\fP\&.
.TP
\fIexp1\fP \fB\-lt\fP \fIexp2\fP
true if \fIexp1\fP is numerically less than \fIexp2\fP\&.
.TP
\fIexp1\fP \fB\-gt\fP \fIexp2\fP
true if \fIexp1\fP is numerically greater than \fIexp2\fP\&.
.TP
\fIexp1\fP \fB\-le\fP \fIexp2\fP
true if \fIexp1\fP is numerically less than or equal to \fIexp2\fP\&.
.TP
\fIexp1\fP \fB\-ge\fP \fIexp2\fP
true if \fIexp1\fP is numerically greater than or equal to \fIexp2\fP\&.
.TP
\fB(\fP \fIexp\fP \fB)\fP
true if \fIexp\fP is true\&.
.TP
\fB!\fP \fIexp\fP
true if \fIexp\fP is false\&.
.TP
\fIexp1\fP \fB&&\fP \fIexp2\fP
true if \fIexp1\fP and \fIexp2\fP are both true\&.
.TP
\fIexp1\fP \fB||\fP \fIexp2\fP
true if either \fIexp1\fP or \fIexp2\fP is true\&.
.PP
Normal shell expansion is performed on the \fIfile\fP, \fIstring\fP and
\fIpattern\fP arguments, but the result of each expansion is constrained to
be a single word, similar to the effect of double quotes\&.  However, pattern
metacharacters are active for the \fIpattern\fP arguments; the patterns
are the same as those used for filename generation, see
\fIzshexpn\fP(1), but there is no special behaviour
of `\fB/\fP' nor initial dots, and no glob qualifiers are allowed\&.
.PP
In each of the above expressions, if
\fIfile\fP is of the form `\fB/dev/fd/\fP\fIn\fP',
where \fIn\fP is an integer,
then the test applied to the open file whose
descriptor number is \fIn\fP,
even if the underlying system does not support
the \fB/dev/fd\fP directory\&.
.PP
In the forms which do numeric comparison, the expressions \fIexp\fP
undergo arithmetic expansion as if they were enclosed in \fB$((\&.\&.\&.))\fP\&.
.PP
For example, the following:
.PP
.RS
.nf
\fB[[ ( \-f foo || \-f bar ) && $report = y* ]] && print File exists\&.\fP
.fi
.RE
.PP
tests if either file \fBfoo\fP or file \fBbar\fP exists, and if so, if the
value of the parameter \fBreport\fP begins with `\fBy\fP'; if the complete
condition is true, the message `\fBFile exists\&.\fP' is printed\&.
.\" Yodl file: Zsh/prompt.yo
.SH "PROMPT EXPANSION"
Prompt sequences undergo a special form of expansion\&.  This type of expansion
is also available using the \fB\-P\fP option to the \fBprint\fP builtin\&.
.PP
If the \fBPROMPT_SUBST\fP option is set, the prompt string is first subjected to
\fIparameter expansion\fP,
\fIcommand substitution\fP and
\fIarithmetic expansion\fP\&.
See
\fIzshexpn\fP(1)\&.

Certain escape sequences may be recognised in the prompt string\&.
.PP
If the \fBPROMPT_BANG\fP option is set, a `\fB!\fP' in the prompt is replaced
by the current history event number\&.  A literal `\fB!\fP' may then be
represented as `\fB!!\fP'\&.
.PP
If the \fBPROMPT_PERCENT\fP option is set, certain escape sequences that
start with `\fB%\fP' are expanded\&.
Some escapes take an optional integer argument, which
should appear between the `\fB%\fP' and the next character of the
sequence\&.  The following escape sequences are recognized:
.PP
.PD 0
.TP
.PD
\fB%%\fP
A `\fB%\fP'\&.
.TP
\fB%)\fP
A `\fB)\fP'\&.
.TP
.PD 0
\fB%d\fP
.TP
.PD
\fB%/\fP
Present working directory (\fB$PWD\fP)\&.  If an integer follows the `\fB%\fP',
it specifies a number of trailing components of \fB$PWD\fP to show; zero
means the whole path\&.  A negative integer specifies leading components,
i\&.e\&. \fB%\-1d\fP specifies the first component\&.
.TP
\fB%~\fP
As \fB%d\fP and \fB%/\fP, but if \fB$PWD\fP has a named directory as its prefix,
that part is replaced by a `\fB~\fP' followed by the name of the directory\&.
If it starts with \fB$HOME\fP, that part is replaced by a `\fB~\fP'\&.
.TP
.PD 0
\fB%h\fP
.TP
.PD
\fB%!\fP
Current history event number\&.
.TP
\fB%L\fP
The current value of \fB$SHLVL\fP\&.
.TP
\fB%M\fP
The full machine hostname\&.
.TP
\fB%m\fP
The hostname up to the first `\fB\&.\fP'\&.
An integer may follow the `\fB%\fP' to specify
how many components of the hostname are desired\&.  With a negative integer,
trailing components of the hostname are shown\&.
.TP
\fB%S\fP (\fB%s\fP)
Start (stop) standout mode\&.
.TP
\fB%U\fP (\fB%u\fP)
Start (stop) underline mode\&.
.TP
\fB%B\fP (\fB%b\fP)
Start (stop) boldface mode\&.
.TP
.PD 0
\fB%t\fP
.TP
.PD
\fB%@\fP
Current time of day, in 12\-hour, am/pm format\&.
.TP
\fB%T\fP
Current time of day, in 24\-hour format\&.
.TP
\fB%*\fP
Current time of day in 24\-hour format, with seconds\&.
.TP
\fB%n\fP
\fB$USERNAME\fP\&.
.TP
\fB%N\fP
The name of the script, sourced file, or shell function that zsh is
currently executing, whichever was started most recently\&.  If there is
none, this is equivalent to the parameter \fB$0\fP\&.  An integer may follow
the `\fB%\fP' to specify a number of trailing path components to show; zero
means the full path\&.  A negative integer specifies leading components\&.
.TP
\fB%i\fP
The line number currently being executed in the script, sourced file, or
shell function given by \fB%N\fP\&.  This is most useful for debugging as part
of \fB$PS4\fP\&.
.TP
\fB%w\fP
The date in \fIday\fP\fB\-\fP\fIdd\fP format\&.
.TP
\fB%W\fP
The date in \fImm\fP\fB/\fP\fIdd\fP\fB/\fP\fIyy\fP format\&.
.TP
\fB%D\fP
The date in \fIyy\fP\fB\-\fP\fImm\fP\fB\-\fP\fIdd\fP format\&.
.TP
\fB%D{\fP\fIstring\fP\fB}\fP
\fIstring\fP is formatted using the \fBstrftime\fP function\&.
See \fIstrftime\fP(3) for more details\&.  Three additional codes are
available:  \fB%f\fP prints the day of the month, like \fB%e\fP but
without any preceding space if the day is a single digit, and
\fB%K\fP/\fB%L\fP correspond to \fB%k\fP/\fB%l\fP for the hour of the day
(24/12 hour clock) in the same way\&.
.TP
\fB%l\fP
The line (tty) the user is logged in on without \fB/dev/\fP prefix\&.
If name starts with \fB/dev/tty\fP this is stripped\&.
.TP
\fB%y\fP
The line (tty) the user is logged in on without \fB/dev/\fP prefix\&.
It does not treat \fB/dev/tty*\fP specially\&.
.TP
\fB%?\fP
The return code of the last command executed just before the prompt\&.
.TP
\fB%_\fP
The status of the parser, i\&.e\&. the shell constructs (like `\fBif\fP' and
`\fBfor\fP') that have been started on the command line\&. If given an integer
number that many strings will be printed; zero or negative or no integer means
print as many as there are\&.  This is most useful in prompts \fBPS2\fP for
continuation lines and \fBPS4\fP for debugging with the \fBXTRACE\fP option; in
the latter case it will also work non\-interactively\&.
.TP
\fB%E\fP
Clears to end of line\&.
.TP
\fB%#\fP
A `\fB#\fP' if the shell is running with privileges, a `\fB%\fP' if not\&.
Equivalent to `\fB%(!\&.#\&.%%)\fP'\&.
The definition of `privileged', for these purposes, is that either the
effective user ID is zero, or, if POSIX\&.1e capabilities are supported, that
at least one capability is raised in either the Effective or Inheritable
capability vectors\&.
.TP
\fB%v\fP
The value of the first element of the \fBpsvar\fP array parameter\&.  Following
the `\fB%\fP' with an integer gives that element of the array\&.  Negative
integers count from the end of the array\&.
.TP
\fB%{\fP\&.\&.\&.\fB%}\fP
Include a string as a literal escape sequence\&.
The string within the braces should not change the cursor
position\&.  Brace pairs can nest\&.
.TP
\fB%(\fP\fIx\&.true\-text\&.false\-text\fP\fB)\fP
Specifies a ternary expression\&.  The character following the \fIx\fP is
arbitrary; the same character is used to separate the text for the
`true' result from that for the `false' result\&.
This separator may not appear in the \fItrue\-text\fP, except as part of a
%\-escape
sequence\&.  A `\fB)\fP' may appear in the \fIfalse\-text\fP as `\fB%)\fP'\&.
\fItrue\-text\fP
and \fIfalse\-text\fP may both contain arbitrarily\-nested escape
sequences, including further ternary expressions\&.
.RS
.PP
The left parenthesis may be preceded or followed by a positive integer \fIn\fP,
which defaults to zero\&.  A negative integer will be multiplied by \-1\&.
The test character \fIx\fP may be any of the following:
.PP
.PD 0
.TP
\fBc\fP
.TP
\fB\&.\fP
.TP
\fB~\fP
True if the current path, with prefix replacement, has at least \fIn\fP elements\&.
.TP
\fB/\fP
.TP
\fBC\fP
True if the current absolute path has at least \fIn\fP elements\&.
.TP
\fBt\fP
True if the time in minutes is equal to \fIn\fP\&.
.TP
\fBT\fP
True if the time in hours is equal to \fIn\fP\&.
.TP
\fBd\fP
True if the day of the month is equal to \fIn\fP\&.
.TP
\fBD\fP
True if the month is equal to \fIn\fP (January = 0)\&.
.TP
\fBw\fP
True if the day of the week is equal to \fIn\fP (Sunday = 0)\&.
.TP
\fB?\fP
True if the exit status of the last command was \fIn\fP\&.
.TP
\fB#\fP
True if the effective uid of the current process is \fIn\fP\&.
.TP
\fBg\fP
True if the effective gid of the current process is \fIn\fP\&.
.TP
\fBl\fP
True if at least \fIn\fP characters have already been
printed on the current line\&.
.TP
\fBL\fP
True if the \fBSHLVL\fP parameter is at least \fIn\fP\&.
.TP
\fBS\fP
True if the \fBSECONDS\fP parameter is at least \fIn\fP\&.
.TP
\fBv\fP
True if the array \fBpsvar\fP has at least \fIn\fP elements\&.
.TP
\fB_\fP
True if at least \fIn\fP shell constructs were started\&.
.TP
\fB!\fP
True if the shell is running with privileges\&.
.PD
.RE
.TP
.PD 0
\fB%<\fP\fIstring\fP\fB<\fP
.TP
.PD 0
\fB%>\fP\fIstring\fP\fB>\fP
.TP
.PD
\fB%[\fP\fIxstring\fP\fB]\fP
Specifies truncation behaviour for the remainder of the prompt string\&.
The third, deprecated, form is equivalent to `\fB%\fP\fIxstringx\fP',
i\&.e\&. \fIx\fP may be `\fB<\fP' or `\fB>\fP'\&.
The numeric argument, which in the third form may appear immediately
after the `\fB[\fP', specifies the maximum permitted length of
the various strings that can be displayed in the prompt\&.
The \fIstring\fP will be displayed in
place of the truncated portion of any string; note this does not
undergo prompt expansion\&.
.RS
.PP
The forms with `\fB<\fP' truncate at the left of the string,
and the forms with `\fB>\fP' truncate at the right of the string\&.
For example, if the current directory is `\fB/home/pike\fP',
the prompt `\fB%8<\&.\&.<%/\fP' will expand to `\fB\&.\&.e/pike\fP'\&.
In this string, the terminating character (`\fB<\fP', `\fB>\fP' or `\fB]\fP'),
or in fact any character, may be quoted by a preceding `\fB\e\fP'; note
when using \fBprint \-P\fP, however, that this must be doubled as the
string is also subject to standard \fBprint\fP processing, in addition
to any backslashes removed by a double quoted string:  the worst case
is therefore `\fBprint \-P "%<\e\e\e\e<<\&.\&.\&."\fP'\&.
.PP
If the \fIstring\fP is longer than the specified truncation length,
it will appear in full, completely replacing the truncated string\&.
.PP
The part of the prompt string to be truncated runs to the end of the
string, or to the end of the next enclosing group of the `\fB%(\fP'
construct, or to the next truncation encountered at the same grouping
level (i\&.e\&. truncations inside a `\fB%(\fP' are separate), which
ever comes first\&.  In particular, a truncation with argument zero
(e\&.g\&. `\fB%<<\fP') marks the end of the range of the string to be
truncated while turning off truncation from there on\&. For example, the
prompt '%10<\&.\&.\&.<%~%<<%# ' will print a truncated representation of the
current directory, followed by a `\fB%\fP' or `\fB#\fP', followed by a
space\&.  Without the `\fB%<<\fP', those two characters would be included
in the string to be truncated\&.
.RE
.TP
.PD 0
\fB%c\fP
.TP
.PD 0
\fB%\&.\fP
.TP
.PD
\fB%C\fP
Trailing component of \fB$PWD\fP\&.
An integer may follow the `\fB%\fP' to get more than one component\&.
Unless `\fB%C\fP' is used, tilde contraction is performed first\&.  These are
deprecated as \fB%c\fP and \fB%C\fP are equivalent to \fB%1~\fP and \fB%1/\fP,
respectively, while explicit positive integers have the same effect as for
the latter two sequences\&.
